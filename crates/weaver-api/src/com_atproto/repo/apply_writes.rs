// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: com.atproto.repo.applyWrites
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

/// Operation which creates a new record.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Create<'a> {
    #[serde(borrow)]
    pub collection: jacquard_common::types::string::Nsid<'a>,
    /// NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub rkey: std::option::Option<
        jacquard_common::types::string::RecordKey<
            jacquard_common::types::string::Rkey<'a>,
        >,
    >,
    #[serde(borrow)]
    pub value: jacquard_common::types::value::Data<'a>,
}

pub mod create_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Collection;
        type Value;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Collection = Unset;
        type Value = Unset;
    }
    ///State transition - sets the `collection` field to Set
    pub struct SetCollection<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCollection<S> {}
    impl<S: State> State for SetCollection<S> {
        type Collection = Set<members::collection>;
        type Value = S::Value;
    }
    ///State transition - sets the `value` field to Set
    pub struct SetValue<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetValue<S> {}
    impl<S: State> State for SetValue<S> {
        type Collection = S::Collection;
        type Value = Set<members::value>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `collection` field
        pub struct collection(());
        ///Marker type for the `value` field
        pub struct value(());
    }
}

/// Builder for constructing an instance of this type
pub struct CreateBuilder<'a, S: create_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Nsid<'a>>,
        ::core::option::Option<
            jacquard_common::types::string::RecordKey<
                jacquard_common::types::string::Rkey<'a>,
            >,
        >,
        ::core::option::Option<jacquard_common::types::value::Data<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Create<'a> {
    /// Create a new builder for this type
    pub fn new() -> CreateBuilder<'a, create_state::Empty> {
        CreateBuilder::new()
    }
}

impl<'a> CreateBuilder<'a, create_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        CreateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> CreateBuilder<'a, S>
where
    S: create_state::State,
    S::Collection: create_state::IsUnset,
{
    /// Set the `collection` field (required)
    pub fn collection(
        mut self,
        value: impl Into<jacquard_common::types::string::Nsid<'a>>,
    ) -> CreateBuilder<'a, create_state::SetCollection<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        CreateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: create_state::State> CreateBuilder<'a, S> {
    /// Set the `rkey` field (optional)
    pub fn rkey(
        mut self,
        value: impl Into<
            Option<
                jacquard_common::types::string::RecordKey<
                    jacquard_common::types::string::Rkey<'a>,
                >,
            >,
        >,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `rkey` field to an Option value (optional)
    pub fn maybe_rkey(
        mut self,
        value: Option<
            jacquard_common::types::string::RecordKey<
                jacquard_common::types::string::Rkey<'a>,
            >,
        >,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> CreateBuilder<'a, S>
where
    S: create_state::State,
    S::Value: create_state::IsUnset,
{
    /// Set the `value` field (required)
    pub fn value(
        mut self,
        value: impl Into<jacquard_common::types::value::Data<'a>>,
    ) -> CreateBuilder<'a, create_state::SetValue<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        CreateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> CreateBuilder<'a, S>
where
    S: create_state::State,
    S::Collection: create_state::IsSet,
    S::Value: create_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Create<'a> {
        Create {
            collection: self.__unsafe_private_named.0.unwrap(),
            rkey: self.__unsafe_private_named.1,
            value: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Create<'a> {
        Create {
            collection: self.__unsafe_private_named.0.unwrap(),
            rkey: self.__unsafe_private_named.1,
            value: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

fn lexicon_doc_com_atproto_repo_applyWrites() -> ::jacquard_lexicon::lexicon::LexiconDoc<
    'static,
> {
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("com.atproto.repo.applyWrites"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::alloc::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("create"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Operation which creates a new record.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("collection"),
                            ::jacquard_common::smol_str::SmolStr::new_static("value")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "collection",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Nsid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("rkey"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::RecordKey,
                                ),
                                default: None,
                                min_length: None,
                                max_length: Some(512usize),
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("value"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                description: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("createResult"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_common::smol_str::SmolStr::new_static("cid")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::AtUri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "validationStatus",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("delete"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Operation which deletes an existing record.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("collection"),
                            ::jacquard_common::smol_str::SmolStr::new_static("rkey")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "collection",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Nsid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("rkey"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::RecordKey,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("deleteResult"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(vec![]),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("main"),
                ::jacquard_lexicon::lexicon::LexUserType::XrpcProcedure(::jacquard_lexicon::lexicon::LexXrpcProcedure {
                    description: None,
                    parameters: None,
                    input: Some(::jacquard_lexicon::lexicon::LexXrpcBody {
                        description: None,
                        encoding: ::jacquard_common::CowStr::new_static(
                            "application/json",
                        ),
                        schema: Some(
                            ::jacquard_lexicon::lexicon::LexXrpcBodySchema::Object(::jacquard_lexicon::lexicon::LexObject {
                                description: None,
                                required: Some(
                                    vec![
                                        ::jacquard_common::smol_str::SmolStr::new_static("repo"),
                                        ::jacquard_common::smol_str::SmolStr::new_static("writes")
                                    ],
                                ),
                                nullable: None,
                                properties: {
                                    #[allow(unused_mut)]
                                    let mut map = ::alloc::collections::BTreeMap::new();
                                    map.insert(
                                        ::jacquard_common::smol_str::SmolStr::new_static("repo"),
                                        ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                            description: Some(
                                                ::jacquard_common::CowStr::new_static(
                                                    "The handle or DID of the repo (aka, current account).",
                                                ),
                                            ),
                                            format: Some(
                                                ::jacquard_lexicon::lexicon::LexStringFormat::AtIdentifier,
                                            ),
                                            default: None,
                                            min_length: None,
                                            max_length: None,
                                            min_graphemes: None,
                                            max_graphemes: None,
                                            r#enum: None,
                                            r#const: None,
                                            known_values: None,
                                        }),
                                    );
                                    map.insert(
                                        ::jacquard_common::smol_str::SmolStr::new_static(
                                            "swapCommit",
                                        ),
                                        ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                            description: Some(
                                                ::jacquard_common::CowStr::new_static(
                                                    "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                                                ),
                                            ),
                                            format: Some(
                                                ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                            ),
                                            default: None,
                                            min_length: None,
                                            max_length: None,
                                            min_graphemes: None,
                                            max_graphemes: None,
                                            r#enum: None,
                                            r#const: None,
                                            known_values: None,
                                        }),
                                    );
                                    map.insert(
                                        ::jacquard_common::smol_str::SmolStr::new_static(
                                            "validate",
                                        ),
                                        ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                            description: None,
                                            default: None,
                                            r#const: None,
                                        }),
                                    );
                                    map.insert(
                                        ::jacquard_common::smol_str::SmolStr::new_static("writes"),
                                        ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                            description: None,
                                            items: ::jacquard_lexicon::lexicon::LexArrayItem::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                                description: None,
                                                refs: vec![
                                                    ::jacquard_common::CowStr::new_static("#create"),
                                                    ::jacquard_common::CowStr::new_static("#update"),
                                                    ::jacquard_common::CowStr::new_static("#delete")
                                                ],
                                                closed: Some(true),
                                            }),
                                            min_length: None,
                                            max_length: None,
                                        }),
                                    );
                                    map
                                },
                            }),
                        ),
                    }),
                    output: None,
                    errors: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("update"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Operation which updates an existing record.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("collection"),
                            ::jacquard_common::smol_str::SmolStr::new_static("rkey"),
                            ::jacquard_common::smol_str::SmolStr::new_static("value")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "collection",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Nsid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("rkey"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::RecordKey,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("value"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                description: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("updateResult"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_common::smol_str::SmolStr::new_static("cid")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::AtUri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "validationStatus",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Create<'a> {
    fn nsid() -> &'static str {
        "com.atproto.repo.applyWrites"
    }
    fn def_name() -> &'static str {
        "create"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_com_atproto_repo_applyWrites()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.rkey {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 512usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "rkey",
                    ),
                    max: 512usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct CreateResult<'a> {
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub validation_status: std::option::Option<CreateResultValidationStatus<'a>>,
}

pub mod create_result_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Uri;
        type Cid;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Uri = Unset;
        type Cid = Unset;
    }
    ///State transition - sets the `uri` field to Set
    pub struct SetUri<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUri<S> {}
    impl<S: State> State for SetUri<S> {
        type Uri = Set<members::uri>;
        type Cid = S::Cid;
    }
    ///State transition - sets the `cid` field to Set
    pub struct SetCid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCid<S> {}
    impl<S: State> State for SetCid<S> {
        type Uri = S::Uri;
        type Cid = Set<members::cid>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `uri` field
        pub struct uri(());
        ///Marker type for the `cid` field
        pub struct cid(());
    }
}

/// Builder for constructing an instance of this type
pub struct CreateResultBuilder<'a, S: create_result_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<jacquard_common::types::string::AtUri<'a>>,
        ::core::option::Option<CreateResultValidationStatus<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> CreateResult<'a> {
    /// Create a new builder for this type
    pub fn new() -> CreateResultBuilder<'a, create_result_state::Empty> {
        CreateResultBuilder::new()
    }
}

impl<'a> CreateResultBuilder<'a, create_result_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        CreateResultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> CreateResultBuilder<'a, S>
where
    S: create_result_state::State,
    S::Cid: create_result_state::IsUnset,
{
    /// Set the `cid` field (required)
    pub fn cid(
        mut self,
        value: impl Into<jacquard_common::types::string::Cid<'a>>,
    ) -> CreateResultBuilder<'a, create_result_state::SetCid<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        CreateResultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> CreateResultBuilder<'a, S>
where
    S: create_result_state::State,
    S::Uri: create_result_state::IsUnset,
{
    /// Set the `uri` field (required)
    pub fn uri(
        mut self,
        value: impl Into<jacquard_common::types::string::AtUri<'a>>,
    ) -> CreateResultBuilder<'a, create_result_state::SetUri<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        CreateResultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: create_result_state::State> CreateResultBuilder<'a, S> {
    /// Set the `validationStatus` field (optional)
    pub fn validation_status(
        mut self,
        value: impl Into<Option<CreateResultValidationStatus<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `validationStatus` field to an Option value (optional)
    pub fn maybe_validation_status(
        mut self,
        value: Option<CreateResultValidationStatus<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> CreateResultBuilder<'a, S>
where
    S: create_result_state::State,
    S::Uri: create_result_state::IsSet,
    S::Cid: create_result_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> CreateResult<'a> {
        CreateResult {
            cid: self.__unsafe_private_named.0.unwrap(),
            uri: self.__unsafe_private_named.1.unwrap(),
            validation_status: self.__unsafe_private_named.2,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> CreateResult<'a> {
        CreateResult {
            cid: self.__unsafe_private_named.0.unwrap(),
            uri: self.__unsafe_private_named.1.unwrap(),
            validation_status: self.__unsafe_private_named.2,
            extra_data: Some(extra_data),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CreateResultValidationStatus<'a> {
    Valid,
    Unknown,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> CreateResultValidationStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Valid => "valid",
            Self::Unknown => "unknown",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for CreateResultValidationStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "valid" => Self::Valid,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for CreateResultValidationStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "valid" => Self::Valid,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for CreateResultValidationStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for CreateResultValidationStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for CreateResultValidationStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for CreateResultValidationStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for CreateResultValidationStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for CreateResultValidationStatus<'_> {
    type Output = CreateResultValidationStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            CreateResultValidationStatus::Valid => CreateResultValidationStatus::Valid,
            CreateResultValidationStatus::Unknown => {
                CreateResultValidationStatus::Unknown
            }
            CreateResultValidationStatus::Other(v) => {
                CreateResultValidationStatus::Other(v.into_static())
            }
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for CreateResult<'a> {
    fn nsid() -> &'static str {
        "com.atproto.repo.applyWrites"
    }
    fn def_name() -> &'static str {
        "createResult"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_com_atproto_repo_applyWrites()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Operation which deletes an existing record.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Delete<'a> {
    #[serde(borrow)]
    pub collection: jacquard_common::types::string::Nsid<'a>,
    #[serde(borrow)]
    pub rkey: jacquard_common::types::string::RecordKey<
        jacquard_common::types::string::Rkey<'a>,
    >,
}

pub mod delete_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Collection;
        type Rkey;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Collection = Unset;
        type Rkey = Unset;
    }
    ///State transition - sets the `collection` field to Set
    pub struct SetCollection<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCollection<S> {}
    impl<S: State> State for SetCollection<S> {
        type Collection = Set<members::collection>;
        type Rkey = S::Rkey;
    }
    ///State transition - sets the `rkey` field to Set
    pub struct SetRkey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRkey<S> {}
    impl<S: State> State for SetRkey<S> {
        type Collection = S::Collection;
        type Rkey = Set<members::rkey>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `collection` field
        pub struct collection(());
        ///Marker type for the `rkey` field
        pub struct rkey(());
    }
}

/// Builder for constructing an instance of this type
pub struct DeleteBuilder<'a, S: delete_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Nsid<'a>>,
        ::core::option::Option<
            jacquard_common::types::string::RecordKey<
                jacquard_common::types::string::Rkey<'a>,
            >,
        >,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Delete<'a> {
    /// Create a new builder for this type
    pub fn new() -> DeleteBuilder<'a, delete_state::Empty> {
        DeleteBuilder::new()
    }
}

impl<'a> DeleteBuilder<'a, delete_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        DeleteBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeleteBuilder<'a, S>
where
    S: delete_state::State,
    S::Collection: delete_state::IsUnset,
{
    /// Set the `collection` field (required)
    pub fn collection(
        mut self,
        value: impl Into<jacquard_common::types::string::Nsid<'a>>,
    ) -> DeleteBuilder<'a, delete_state::SetCollection<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        DeleteBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeleteBuilder<'a, S>
where
    S: delete_state::State,
    S::Rkey: delete_state::IsUnset,
{
    /// Set the `rkey` field (required)
    pub fn rkey(
        mut self,
        value: impl Into<
            jacquard_common::types::string::RecordKey<
                jacquard_common::types::string::Rkey<'a>,
            >,
        >,
    ) -> DeleteBuilder<'a, delete_state::SetRkey<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        DeleteBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeleteBuilder<'a, S>
where
    S: delete_state::State,
    S::Collection: delete_state::IsSet,
    S::Rkey: delete_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Delete<'a> {
        Delete {
            collection: self.__unsafe_private_named.0.unwrap(),
            rkey: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Delete<'a> {
        Delete {
            collection: self.__unsafe_private_named.0.unwrap(),
            rkey: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Delete<'a> {
    fn nsid() -> &'static str {
        "com.atproto.repo.applyWrites"
    }
    fn def_name() -> &'static str {
        "delete"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_com_atproto_repo_applyWrites()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct DeleteResult<'a> {}
impl<'a> ::jacquard_lexicon::schema::LexiconSchema for DeleteResult<'a> {
    fn nsid() -> &'static str {
        "com.atproto.repo.applyWrites"
    }
    fn def_name() -> &'static str {
        "deleteResult"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_com_atproto_repo_applyWrites()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ApplyWrites<'a> {
    /// The handle or DID of the repo (aka, current account).
    #[serde(borrow)]
    pub repo: jacquard_common::types::ident::AtIdentifier<'a>,
    /// If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub swap_commit: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    /// Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub validate: std::option::Option<bool>,
    #[serde(borrow)]
    pub writes: Vec<ApplyWritesWritesItem<'a>>,
}

pub mod apply_writes_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Writes;
        type Repo;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Writes = Unset;
        type Repo = Unset;
    }
    ///State transition - sets the `writes` field to Set
    pub struct SetWrites<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetWrites<S> {}
    impl<S: State> State for SetWrites<S> {
        type Writes = Set<members::writes>;
        type Repo = S::Repo;
    }
    ///State transition - sets the `repo` field to Set
    pub struct SetRepo<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRepo<S> {}
    impl<S: State> State for SetRepo<S> {
        type Writes = S::Writes;
        type Repo = Set<members::repo>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `writes` field
        pub struct writes(());
        ///Marker type for the `repo` field
        pub struct repo(());
    }
}

/// Builder for constructing an instance of this type
pub struct ApplyWritesBuilder<'a, S: apply_writes_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::ident::AtIdentifier<'a>>,
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<bool>,
        ::core::option::Option<Vec<ApplyWritesWritesItem<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ApplyWrites<'a> {
    /// Create a new builder for this type
    pub fn new() -> ApplyWritesBuilder<'a, apply_writes_state::Empty> {
        ApplyWritesBuilder::new()
    }
}

impl<'a> ApplyWritesBuilder<'a, apply_writes_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ApplyWritesBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ApplyWritesBuilder<'a, S>
where
    S: apply_writes_state::State,
    S::Repo: apply_writes_state::IsUnset,
{
    /// Set the `repo` field (required)
    pub fn repo(
        mut self,
        value: impl Into<jacquard_common::types::ident::AtIdentifier<'a>>,
    ) -> ApplyWritesBuilder<'a, apply_writes_state::SetRepo<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ApplyWritesBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: apply_writes_state::State> ApplyWritesBuilder<'a, S> {
    /// Set the `swapCommit` field (optional)
    pub fn swap_commit(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Cid<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `swapCommit` field to an Option value (optional)
    pub fn maybe_swap_commit(
        mut self,
        value: Option<jacquard_common::types::string::Cid<'a>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: apply_writes_state::State> ApplyWritesBuilder<'a, S> {
    /// Set the `validate` field (optional)
    pub fn validate(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `validate` field to an Option value (optional)
    pub fn maybe_validate(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> ApplyWritesBuilder<'a, S>
where
    S: apply_writes_state::State,
    S::Writes: apply_writes_state::IsUnset,
{
    /// Set the `writes` field (required)
    pub fn writes(
        mut self,
        value: impl Into<Vec<ApplyWritesWritesItem<'a>>>,
    ) -> ApplyWritesBuilder<'a, apply_writes_state::SetWrites<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ApplyWritesBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ApplyWritesBuilder<'a, S>
where
    S: apply_writes_state::State,
    S::Writes: apply_writes_state::IsSet,
    S::Repo: apply_writes_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ApplyWrites<'a> {
        ApplyWrites {
            repo: self.__unsafe_private_named.0.unwrap(),
            swap_commit: self.__unsafe_private_named.1,
            validate: self.__unsafe_private_named.2,
            writes: self.__unsafe_private_named.3.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ApplyWrites<'a> {
        ApplyWrites {
            repo: self.__unsafe_private_named.0.unwrap(),
            swap_commit: self.__unsafe_private_named.1,
            validate: self.__unsafe_private_named.2,
            writes: self.__unsafe_private_named.3.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ApplyWritesWritesItem<'a> {
    #[serde(rename = "com.atproto.repo.applyWrites#create")]
    Create(Box<crate::com_atproto::repo::apply_writes::Create<'a>>),
    #[serde(rename = "com.atproto.repo.applyWrites#update")]
    Update(Box<crate::com_atproto::repo::apply_writes::Update<'a>>),
    #[serde(rename = "com.atproto.repo.applyWrites#delete")]
    Delete(Box<crate::com_atproto::repo::apply_writes::Delete<'a>>),
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ApplyWritesOutput<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub commit: std::option::Option<crate::com_atproto::repo::CommitMeta<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub results: std::option::Option<Vec<ApplyWritesOutputResultsItem<'a>>>,
}

#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ApplyWritesOutputResultsItem<'a> {
    #[serde(rename = "com.atproto.repo.applyWrites#createResult")]
    CreateResult(Box<crate::com_atproto::repo::apply_writes::CreateResult<'a>>),
    #[serde(rename = "com.atproto.repo.applyWrites#updateResult")]
    UpdateResult(Box<crate::com_atproto::repo::apply_writes::UpdateResult<'a>>),
    #[serde(rename = "com.atproto.repo.applyWrites#deleteResult")]
    DeleteResult(Box<crate::com_atproto::repo::apply_writes::DeleteResult<'a>>),
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    thiserror::Error,
    miette::Diagnostic,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "error", content = "message")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ApplyWritesError<'a> {
    /// Indicates that the 'swapCommit' parameter did not match current commit.
    #[serde(rename = "InvalidSwap")]
    InvalidSwap(std::option::Option<jacquard_common::CowStr<'a>>),
}

impl core::fmt::Display for ApplyWritesError<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidSwap(msg) => {
                write!(f, "InvalidSwap")?;
                if let Some(msg) = msg {
                    write!(f, ": {}", msg)?;
                }
                Ok(())
            }
            Self::Unknown(err) => write!(f, "Unknown error: {:?}", err),
        }
    }
}

/// Response type for
///com.atproto.repo.applyWrites
pub struct ApplyWritesResponse;
impl jacquard_common::xrpc::XrpcResp for ApplyWritesResponse {
    const NSID: &'static str = "com.atproto.repo.applyWrites";
    const ENCODING: &'static str = "application/json";
    type Output<'de> = ApplyWritesOutput<'de>;
    type Err<'de> = ApplyWritesError<'de>;
}

impl<'a> jacquard_common::xrpc::XrpcRequest for ApplyWrites<'a> {
    const NSID: &'static str = "com.atproto.repo.applyWrites";
    const METHOD: jacquard_common::xrpc::XrpcMethod = jacquard_common::xrpc::XrpcMethod::Procedure(
        "application/json",
    );
    type Response = ApplyWritesResponse;
}

/// Endpoint type for
///com.atproto.repo.applyWrites
pub struct ApplyWritesRequest;
impl jacquard_common::xrpc::XrpcEndpoint for ApplyWritesRequest {
    const PATH: &'static str = "/xrpc/com.atproto.repo.applyWrites";
    const METHOD: jacquard_common::xrpc::XrpcMethod = jacquard_common::xrpc::XrpcMethod::Procedure(
        "application/json",
    );
    type Request<'de> = ApplyWrites<'de>;
    type Response = ApplyWritesResponse;
}

/// Operation which updates an existing record.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Update<'a> {
    #[serde(borrow)]
    pub collection: jacquard_common::types::string::Nsid<'a>,
    #[serde(borrow)]
    pub rkey: jacquard_common::types::string::RecordKey<
        jacquard_common::types::string::Rkey<'a>,
    >,
    #[serde(borrow)]
    pub value: jacquard_common::types::value::Data<'a>,
}

pub mod update_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Collection;
        type Rkey;
        type Value;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Collection = Unset;
        type Rkey = Unset;
        type Value = Unset;
    }
    ///State transition - sets the `collection` field to Set
    pub struct SetCollection<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCollection<S> {}
    impl<S: State> State for SetCollection<S> {
        type Collection = Set<members::collection>;
        type Rkey = S::Rkey;
        type Value = S::Value;
    }
    ///State transition - sets the `rkey` field to Set
    pub struct SetRkey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRkey<S> {}
    impl<S: State> State for SetRkey<S> {
        type Collection = S::Collection;
        type Rkey = Set<members::rkey>;
        type Value = S::Value;
    }
    ///State transition - sets the `value` field to Set
    pub struct SetValue<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetValue<S> {}
    impl<S: State> State for SetValue<S> {
        type Collection = S::Collection;
        type Rkey = S::Rkey;
        type Value = Set<members::value>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `collection` field
        pub struct collection(());
        ///Marker type for the `rkey` field
        pub struct rkey(());
        ///Marker type for the `value` field
        pub struct value(());
    }
}

/// Builder for constructing an instance of this type
pub struct UpdateBuilder<'a, S: update_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Nsid<'a>>,
        ::core::option::Option<
            jacquard_common::types::string::RecordKey<
                jacquard_common::types::string::Rkey<'a>,
            >,
        >,
        ::core::option::Option<jacquard_common::types::value::Data<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Update<'a> {
    /// Create a new builder for this type
    pub fn new() -> UpdateBuilder<'a, update_state::Empty> {
        UpdateBuilder::new()
    }
}

impl<'a> UpdateBuilder<'a, update_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        UpdateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> UpdateBuilder<'a, S>
where
    S: update_state::State,
    S::Collection: update_state::IsUnset,
{
    /// Set the `collection` field (required)
    pub fn collection(
        mut self,
        value: impl Into<jacquard_common::types::string::Nsid<'a>>,
    ) -> UpdateBuilder<'a, update_state::SetCollection<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        UpdateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> UpdateBuilder<'a, S>
where
    S: update_state::State,
    S::Rkey: update_state::IsUnset,
{
    /// Set the `rkey` field (required)
    pub fn rkey(
        mut self,
        value: impl Into<
            jacquard_common::types::string::RecordKey<
                jacquard_common::types::string::Rkey<'a>,
            >,
        >,
    ) -> UpdateBuilder<'a, update_state::SetRkey<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        UpdateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> UpdateBuilder<'a, S>
where
    S: update_state::State,
    S::Value: update_state::IsUnset,
{
    /// Set the `value` field (required)
    pub fn value(
        mut self,
        value: impl Into<jacquard_common::types::value::Data<'a>>,
    ) -> UpdateBuilder<'a, update_state::SetValue<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        UpdateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> UpdateBuilder<'a, S>
where
    S: update_state::State,
    S::Collection: update_state::IsSet,
    S::Rkey: update_state::IsSet,
    S::Value: update_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Update<'a> {
        Update {
            collection: self.__unsafe_private_named.0.unwrap(),
            rkey: self.__unsafe_private_named.1.unwrap(),
            value: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Update<'a> {
        Update {
            collection: self.__unsafe_private_named.0.unwrap(),
            rkey: self.__unsafe_private_named.1.unwrap(),
            value: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Update<'a> {
    fn nsid() -> &'static str {
        "com.atproto.repo.applyWrites"
    }
    fn def_name() -> &'static str {
        "update"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_com_atproto_repo_applyWrites()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct UpdateResult<'a> {
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub validation_status: std::option::Option<UpdateResultValidationStatus<'a>>,
}

pub mod update_result_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Cid;
        type Uri;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Cid = Unset;
        type Uri = Unset;
    }
    ///State transition - sets the `cid` field to Set
    pub struct SetCid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCid<S> {}
    impl<S: State> State for SetCid<S> {
        type Cid = Set<members::cid>;
        type Uri = S::Uri;
    }
    ///State transition - sets the `uri` field to Set
    pub struct SetUri<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUri<S> {}
    impl<S: State> State for SetUri<S> {
        type Cid = S::Cid;
        type Uri = Set<members::uri>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `cid` field
        pub struct cid(());
        ///Marker type for the `uri` field
        pub struct uri(());
    }
}

/// Builder for constructing an instance of this type
pub struct UpdateResultBuilder<'a, S: update_result_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<jacquard_common::types::string::AtUri<'a>>,
        ::core::option::Option<UpdateResultValidationStatus<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> UpdateResult<'a> {
    /// Create a new builder for this type
    pub fn new() -> UpdateResultBuilder<'a, update_result_state::Empty> {
        UpdateResultBuilder::new()
    }
}

impl<'a> UpdateResultBuilder<'a, update_result_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        UpdateResultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> UpdateResultBuilder<'a, S>
where
    S: update_result_state::State,
    S::Cid: update_result_state::IsUnset,
{
    /// Set the `cid` field (required)
    pub fn cid(
        mut self,
        value: impl Into<jacquard_common::types::string::Cid<'a>>,
    ) -> UpdateResultBuilder<'a, update_result_state::SetCid<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        UpdateResultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> UpdateResultBuilder<'a, S>
where
    S: update_result_state::State,
    S::Uri: update_result_state::IsUnset,
{
    /// Set the `uri` field (required)
    pub fn uri(
        mut self,
        value: impl Into<jacquard_common::types::string::AtUri<'a>>,
    ) -> UpdateResultBuilder<'a, update_result_state::SetUri<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        UpdateResultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: update_result_state::State> UpdateResultBuilder<'a, S> {
    /// Set the `validationStatus` field (optional)
    pub fn validation_status(
        mut self,
        value: impl Into<Option<UpdateResultValidationStatus<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `validationStatus` field to an Option value (optional)
    pub fn maybe_validation_status(
        mut self,
        value: Option<UpdateResultValidationStatus<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> UpdateResultBuilder<'a, S>
where
    S: update_result_state::State,
    S::Cid: update_result_state::IsSet,
    S::Uri: update_result_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> UpdateResult<'a> {
        UpdateResult {
            cid: self.__unsafe_private_named.0.unwrap(),
            uri: self.__unsafe_private_named.1.unwrap(),
            validation_status: self.__unsafe_private_named.2,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> UpdateResult<'a> {
        UpdateResult {
            cid: self.__unsafe_private_named.0.unwrap(),
            uri: self.__unsafe_private_named.1.unwrap(),
            validation_status: self.__unsafe_private_named.2,
            extra_data: Some(extra_data),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UpdateResultValidationStatus<'a> {
    Valid,
    Unknown,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> UpdateResultValidationStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Valid => "valid",
            Self::Unknown => "unknown",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for UpdateResultValidationStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "valid" => Self::Valid,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for UpdateResultValidationStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "valid" => Self::Valid,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for UpdateResultValidationStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for UpdateResultValidationStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for UpdateResultValidationStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for UpdateResultValidationStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for UpdateResultValidationStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for UpdateResultValidationStatus<'_> {
    type Output = UpdateResultValidationStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            UpdateResultValidationStatus::Valid => UpdateResultValidationStatus::Valid,
            UpdateResultValidationStatus::Unknown => {
                UpdateResultValidationStatus::Unknown
            }
            UpdateResultValidationStatus::Other(v) => {
                UpdateResultValidationStatus::Other(v.into_static())
            }
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for UpdateResult<'a> {
    fn nsid() -> &'static str {
        "com.atproto.repo.applyWrites"
    }
    fn def_name() -> &'static str {
        "updateResult"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_com_atproto_repo_applyWrites()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}