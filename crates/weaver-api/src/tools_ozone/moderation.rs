// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: tools.ozone.moderation.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod cancel_scheduled_actions;
pub mod emit_event;
pub mod get_account_timeline;
pub mod get_event;
pub mod get_record;
pub mod get_records;
pub mod get_repo;
pub mod get_reporter_stats;
pub mod get_repos;
pub mod get_subjects;
pub mod list_scheduled_actions;
pub mod query_events;
pub mod query_statuses;
pub mod schedule_action;
pub mod search_repos;

/// Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct AccountEvent<'a> {
    /// Indicates that the account has a repository which can be fetched from the host that emitted this event.
    pub active: bool,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<AccountEventStatus<'a>>,
    pub timestamp: jacquard_common::types::string::Datetime,
}

pub mod account_event_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Timestamp;
        type Active;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Timestamp = Unset;
        type Active = Unset;
    }
    ///State transition - sets the `timestamp` field to Set
    pub struct SetTimestamp<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetTimestamp<S> {}
    impl<S: State> State for SetTimestamp<S> {
        type Timestamp = Set<members::timestamp>;
        type Active = S::Active;
    }
    ///State transition - sets the `active` field to Set
    pub struct SetActive<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetActive<S> {}
    impl<S: State> State for SetActive<S> {
        type Timestamp = S::Timestamp;
        type Active = Set<members::active>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `timestamp` field
        pub struct timestamp(());
        ///Marker type for the `active` field
        pub struct active(());
    }
}

/// Builder for constructing an instance of this type
pub struct AccountEventBuilder<'a, S: account_event_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<bool>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<AccountEventStatus<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> AccountEvent<'a> {
    /// Create a new builder for this type
    pub fn new() -> AccountEventBuilder<'a, account_event_state::Empty> {
        AccountEventBuilder::new()
    }
}

impl<'a> AccountEventBuilder<'a, account_event_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        AccountEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> AccountEventBuilder<'a, S>
where
    S: account_event_state::State,
    S::Active: account_event_state::IsUnset,
{
    /// Set the `active` field (required)
    pub fn active(
        mut self,
        value: impl Into<bool>,
    ) -> AccountEventBuilder<'a, account_event_state::SetActive<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        AccountEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: account_event_state::State> AccountEventBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: account_event_state::State> AccountEventBuilder<'a, S> {
    /// Set the `status` field (optional)
    pub fn status(mut self, value: impl Into<Option<AccountEventStatus<'a>>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `status` field to an Option value (optional)
    pub fn maybe_status(mut self, value: Option<AccountEventStatus<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> AccountEventBuilder<'a, S>
where
    S: account_event_state::State,
    S::Timestamp: account_event_state::IsUnset,
{
    /// Set the `timestamp` field (required)
    pub fn timestamp(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> AccountEventBuilder<'a, account_event_state::SetTimestamp<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        AccountEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> AccountEventBuilder<'a, S>
where
    S: account_event_state::State,
    S::Timestamp: account_event_state::IsSet,
    S::Active: account_event_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> AccountEvent<'a> {
        AccountEvent {
            active: self.__unsafe_private_named.0.unwrap(),
            comment: self.__unsafe_private_named.1,
            status: self.__unsafe_private_named.2,
            timestamp: self.__unsafe_private_named.3.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> AccountEvent<'a> {
        AccountEvent {
            active: self.__unsafe_private_named.0.unwrap(),
            comment: self.__unsafe_private_named.1,
            status: self.__unsafe_private_named.2,
            timestamp: self.__unsafe_private_named.3.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AccountEventStatus<'a> {
    Unknown,
    Deactivated,
    Deleted,
    Takendown,
    Suspended,
    Tombstoned,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> AccountEventStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::Deactivated => "deactivated",
            Self::Deleted => "deleted",
            Self::Takendown => "takendown",
            Self::Suspended => "suspended",
            Self::Tombstoned => "tombstoned",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for AccountEventStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "unknown" => Self::Unknown,
            "deactivated" => Self::Deactivated,
            "deleted" => Self::Deleted,
            "takendown" => Self::Takendown,
            "suspended" => Self::Suspended,
            "tombstoned" => Self::Tombstoned,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for AccountEventStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "unknown" => Self::Unknown,
            "deactivated" => Self::Deactivated,
            "deleted" => Self::Deleted,
            "takendown" => Self::Takendown,
            "suspended" => Self::Suspended,
            "tombstoned" => Self::Tombstoned,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for AccountEventStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for AccountEventStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for AccountEventStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for AccountEventStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for AccountEventStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for AccountEventStatus<'_> {
    type Output = AccountEventStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            AccountEventStatus::Unknown => AccountEventStatus::Unknown,
            AccountEventStatus::Deactivated => AccountEventStatus::Deactivated,
            AccountEventStatus::Deleted => AccountEventStatus::Deleted,
            AccountEventStatus::Takendown => AccountEventStatus::Takendown,
            AccountEventStatus::Suspended => AccountEventStatus::Suspended,
            AccountEventStatus::Tombstoned => AccountEventStatus::Tombstoned,
            AccountEventStatus::Other(v) => AccountEventStatus::Other(v.into_static()),
        }
    }
}

fn lexicon_doc_tools_ozone_moderation_defs() -> ::jacquard_lexicon::lexicon::LexiconDoc<
    'static,
> {
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("tools.ozone.moderation.defs"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::alloc::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("accountEvent"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("timestamp"),
                            ::jacquard_common::smol_str::SmolStr::new_static("active")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("active"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "timestamp",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("accountHosting"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("status")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deactivatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deletedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reactivatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "updatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("accountStats"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Statistics about a particular account subject",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "appealCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "escalateCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reportCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "suspendCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "takedownCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("accountStrike"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Strike information for an account",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "activeStrikeCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "firstStrikeAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Timestamp of the first strike received",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastStrikeAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Timestamp of the most recent strike received",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "totalStrikeCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("ageAssuranceEvent"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age assurance info coming directly from users. Only works on DID subjects.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_common::smol_str::SmolStr::new_static("attemptId")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "attemptId",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The unique identifier for this instance of the age assurance flow, in UUID format.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "completeIp",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The IP address used when completing the AA flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "completeUa",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The user agent used when completing the AA flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "countryCode",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ISO 3166-1 alpha-2 country code provided when beginning the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The date and time of this write operation.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("initIp"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The IP address used when initiating the AA flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("initUa"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The user agent used when initiating the AA flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "regionCode",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ISO 3166-2 region code provided when beginning the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The status of the Age Assurance process.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "ageAssuranceOverrideEvent",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age assurance status override by moderators. Only works on DID subjects.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_common::smol_str::SmolStr::new_static("status")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Comment describing the reason for the override.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The status to be set for the user decided by a moderator, overriding whatever value the user had previously. Use reset to default to original state.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("blobView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_common::smol_str::SmolStr::new_static("mimeType"),
                            ::jacquard_common::smol_str::SmolStr::new_static("size"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("details"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("#imageDetails"),
                                    ::jacquard_common::CowStr::new_static("#videoDetails")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("mimeType"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "moderation",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#moderation"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("size"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "cancelScheduledTakedownEvent",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Logs cancellation of a scheduled takedown action for an account.",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("identityEvent"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("timestamp")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("handle"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Handle,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("pdsHost"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Uri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "timestamp",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "tombstone",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("imageDetails"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_common::smol_str::SmolStr::new_static("height")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("height"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventAcknowledge"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "acknowledgeAccountSubjects",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventComment"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Add a comment to a subject. An empty comment will clear any previously set sticky comment.",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("sticky"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventDivert"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Divert a record's blobs to a 3rd party service for further scanning/tagging",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventEmail"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Keep a log of outgoing email to a user",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("subjectLine")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Additional comment about the outgoing comm.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("content"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The content of the email sent to the user.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "isDelivered",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("policies"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Names/Keywords of the policies that necessitated the email.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: Some(5usize),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "severityLevel",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Severity level of the violation. Normally 'sev-1' that adds strike on repeat offense",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "strikeCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "strikeExpiresAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When the strike should expire. If not provided, the strike never expires.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectLine",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The subject line of the email sent to the user.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventEscalate"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventLabel"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Apply/Negate labels on a subject",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("createLabelVals"),
                            ::jacquard_common::smol_str::SmolStr::new_static("negateLabelVals")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createLabelVals",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "durationInHours",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "negateLabelVals",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventMute"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Mute incoming reports on a subject",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("durationInHours")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "durationInHours",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventMuteReporter"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Mute incoming reports from an account",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "durationInHours",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "modEventPriorityScore",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Set priority score of the subject. Higher score means higher priority.",
                        ),
                    ),
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("score")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("score"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: Some(0i64),
                                maximum: Some(100i64),
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventReport"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static("Report a subject"),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("reportType")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "isReporterMuted",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reportType",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "com.atproto.moderation.defs#reasonType",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "modEventResolveAppeal",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Resolve appeal on a subject",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Describe resolution.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "modEventReverseTakedown",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Revert take down action on a subject",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Describe reasoning behind the reversal.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("policies"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Names/Keywords of the policy infraction for which takedown is being reversed.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: Some(5usize),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "severityLevel",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Severity level of the violation. Usually set from the last policy infraction's severity.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "strikeCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventTag"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Add/Remove a tag on a subject",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("add"),
                            ::jacquard_common::smol_str::SmolStr::new_static("remove")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("add"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Tags to be added to the subject. If already exists, won't be duplicated.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Additional comment about added/removed tags.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("remove"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventTakedown"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Take down a subject permanently or temporarily",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "acknowledgeAccountSubjects",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "durationInHours",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("policies"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Names/Keywords of the policies that drove the decision.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: Some(5usize),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "severityLevel",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Severity level of the violation (e.g., 'sev-0', 'sev-1', 'sev-2', etc.).",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "strikeCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "strikeExpiresAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When the strike should expire. If not provided, the strike never expires.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "targetServices",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "List of services where the takedown should be applied. If empty or not provided, takedown is applied on all configured services.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventUnmute"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Unmute action on a subject",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Describe reasoning behind the reversal.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "modEventUnmuteReporter",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Unmute incoming reports from an account",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Describe reasoning behind the reversal.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_common::smol_str::SmolStr::new_static("event"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subjectBlobCids"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdBy"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "creatorHandle",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("event"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("#modEventTakedown"),
                                    ::jacquard_common::CowStr::new_static("#modEventReverseTakedown"),
                                    ::jacquard_common::CowStr::new_static("#modEventComment"),
                                    ::jacquard_common::CowStr::new_static("#modEventReport"),
                                    ::jacquard_common::CowStr::new_static("#modEventLabel"),
                                    ::jacquard_common::CowStr::new_static("#modEventAcknowledge"),
                                    ::jacquard_common::CowStr::new_static("#modEventEscalate"),
                                    ::jacquard_common::CowStr::new_static("#modEventMute"),
                                    ::jacquard_common::CowStr::new_static("#modEventUnmute"),
                                    ::jacquard_common::CowStr::new_static("#modEventMuteReporter"),
                                    ::jacquard_common::CowStr::new_static("#modEventUnmuteReporter"),
                                    ::jacquard_common::CowStr::new_static("#modEventEmail"),
                                    ::jacquard_common::CowStr::new_static("#modEventResolveAppeal"),
                                    ::jacquard_common::CowStr::new_static("#modEventDivert"),
                                    ::jacquard_common::CowStr::new_static("#modEventTag"),
                                    ::jacquard_common::CowStr::new_static("#accountEvent"),
                                    ::jacquard_common::CowStr::new_static("#identityEvent"),
                                    ::jacquard_common::CowStr::new_static("#recordEvent"),
                                    ::jacquard_common::CowStr::new_static("#modEventPriorityScore"),
                                    ::jacquard_common::CowStr::new_static("#ageAssuranceEvent"),
                                    ::jacquard_common::CowStr::new_static("#ageAssuranceOverrideEvent"),
                                    ::jacquard_common::CowStr::new_static("#revokeAccountCredentialsEvent"),
                                    ::jacquard_common::CowStr::new_static("#scheduleTakedownEvent"),
                                    ::jacquard_common::CowStr::new_static("#cancelScheduledTakedownEvent")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("modTool"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#modTool"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("com.atproto.admin.defs#repoRef"),
                                    ::jacquard_common::CowStr::new_static("com.atproto.repo.strongRef"),
                                    ::jacquard_common::CowStr::new_static("chat.bsky.convo.defs#messageRef")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectBlobCids",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectHandle",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modEventViewDetail"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_common::smol_str::SmolStr::new_static("event"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subjectBlobs"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdBy"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("event"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("#modEventTakedown"),
                                    ::jacquard_common::CowStr::new_static("#modEventReverseTakedown"),
                                    ::jacquard_common::CowStr::new_static("#modEventComment"),
                                    ::jacquard_common::CowStr::new_static("#modEventReport"),
                                    ::jacquard_common::CowStr::new_static("#modEventLabel"),
                                    ::jacquard_common::CowStr::new_static("#modEventAcknowledge"),
                                    ::jacquard_common::CowStr::new_static("#modEventEscalate"),
                                    ::jacquard_common::CowStr::new_static("#modEventMute"),
                                    ::jacquard_common::CowStr::new_static("#modEventUnmute"),
                                    ::jacquard_common::CowStr::new_static("#modEventMuteReporter"),
                                    ::jacquard_common::CowStr::new_static("#modEventUnmuteReporter"),
                                    ::jacquard_common::CowStr::new_static("#modEventEmail"),
                                    ::jacquard_common::CowStr::new_static("#modEventResolveAppeal"),
                                    ::jacquard_common::CowStr::new_static("#modEventDivert"),
                                    ::jacquard_common::CowStr::new_static("#modEventTag"),
                                    ::jacquard_common::CowStr::new_static("#accountEvent"),
                                    ::jacquard_common::CowStr::new_static("#identityEvent"),
                                    ::jacquard_common::CowStr::new_static("#recordEvent"),
                                    ::jacquard_common::CowStr::new_static("#modEventPriorityScore"),
                                    ::jacquard_common::CowStr::new_static("#ageAssuranceEvent"),
                                    ::jacquard_common::CowStr::new_static("#ageAssuranceOverrideEvent"),
                                    ::jacquard_common::CowStr::new_static("#revokeAccountCredentialsEvent"),
                                    ::jacquard_common::CowStr::new_static("#scheduleTakedownEvent"),
                                    ::jacquard_common::CowStr::new_static("#cancelScheduledTakedownEvent")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("modTool"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#modTool"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("#repoView"),
                                    ::jacquard_common::CowStr::new_static("#repoViewNotFound"),
                                    ::jacquard_common::CowStr::new_static("#recordView"),
                                    ::jacquard_common::CowStr::new_static("#recordViewNotFound")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectBlobs",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#blobView"),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("modTool"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Moderation tool information for tracing the source of the action",
                        ),
                    ),
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("name")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("meta"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                description: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("name"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Name/identifier of the source (e.g., 'automod', 'ozone/workspace')",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("moderation"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectStatus",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#subjectStatusView",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("moderationDetail"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectStatus",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#subjectStatusView",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recordEvent"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("timestamp"),
                            ::jacquard_common::smol_str::SmolStr::new_static("op")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("op"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "timestamp",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recordHosting"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("status")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deletedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "updatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recordView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_common::smol_str::SmolStr::new_static("value"),
                            ::jacquard_common::smol_str::SmolStr::new_static("blobCids"),
                            ::jacquard_common::smol_str::SmolStr::new_static("indexedAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("moderation"),
                            ::jacquard_common::smol_str::SmolStr::new_static("repo")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("blobCids"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: Some(
                                        ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                    ),
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "indexedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "moderation",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#moderation"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("repo"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#repoView"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::AtUri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("value"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                description: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recordViewDetail"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_common::smol_str::SmolStr::new_static("value"),
                            ::jacquard_common::smol_str::SmolStr::new_static("blobs"),
                            ::jacquard_common::smol_str::SmolStr::new_static("indexedAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("moderation"),
                            ::jacquard_common::smol_str::SmolStr::new_static("repo")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("blobs"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#blobView"),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "indexedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("labels"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static(
                                        "com.atproto.label.defs#label",
                                    ),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "moderation",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#moderationDetail",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("repo"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#repoView"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::AtUri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("value"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                description: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recordViewNotFound"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("uri")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("uri"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::AtUri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recordsStats"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Statistics about a set of record subject items",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "appealedCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "escalatedCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "pendingCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "processedCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reportedCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "takendownCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "totalReports",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("repoView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_common::smol_str::SmolStr::new_static("handle"),
                            ::jacquard_common::smol_str::SmolStr::new_static("relatedRecords"),
                            ::jacquard_common::smol_str::SmolStr::new_static("indexedAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("moderation")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deactivatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("email"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("handle"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Handle,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "indexedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "inviteNote",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "invitedBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "com.atproto.server.defs#inviteCode",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "invitesDisabled",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "moderation",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static("#moderation"),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "relatedRecords",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                    description: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "threatSignatures",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static(
                                        "com.atproto.admin.defs#threatSignature",
                                    ),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("repoViewDetail"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_common::smol_str::SmolStr::new_static("handle"),
                            ::jacquard_common::smol_str::SmolStr::new_static("relatedRecords"),
                            ::jacquard_common::smol_str::SmolStr::new_static("indexedAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("moderation")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deactivatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("email"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "emailConfirmedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("handle"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Handle,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "indexedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "inviteNote",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "invitedBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "com.atproto.server.defs#inviteCode",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("invites"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static(
                                        "com.atproto.server.defs#inviteCode",
                                    ),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "invitesDisabled",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("labels"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static(
                                        "com.atproto.label.defs#label",
                                    ),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "moderation",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#moderationDetail",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "relatedRecords",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                    description: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "threatSignatures",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static(
                                        "com.atproto.admin.defs#threatSignature",
                                    ),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("repoViewNotFound"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("did")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("reporterStats"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_common::smol_str::SmolStr::new_static("accountReportCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("recordReportCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("reportedAccountCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("reportedRecordCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("takendownAccountCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("takendownRecordCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("labeledAccountCount"),
                            ::jacquard_common::smol_str::SmolStr::new_static("labeledRecordCount")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "accountReportCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "labeledAccountCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "labeledRecordCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "recordReportCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reportedAccountCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reportedRecordCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "takendownAccountCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "takendownRecordCount",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("reviewClosed"),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("reviewEscalated"),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("reviewNone"),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("reviewOpen"),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "revokeAccountCredentialsEvent",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Account credentials revocation by moderators. Only works on DID subjects.",
                        ),
                    ),
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("comment")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Comment describing the reason for the revocation.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "scheduleTakedownEvent",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Logs a scheduled takedown action for an account.",
                        ),
                    ),
                    required: None,
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executeAfter",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executeAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executeUntil",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("scheduledActionView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "View of a scheduled moderation action",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_common::smol_str::SmolStr::new_static("action"),
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdBy"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("status")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("action"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Type of action to be executed",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When the scheduled action was created",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "DID of the user who created this scheduled action",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Subject DID for the action",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "eventData",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Unknown(::jacquard_lexicon::lexicon::LexUnknown {
                                description: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executeAfter",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Earliest time to execute the action (for randomized scheduling)",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executeAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Exact time to execute the action",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executeUntil",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Latest time to execute the action (for randomized scheduling)",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "executionEventId",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastExecutedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When the action was last attempted to be executed",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastFailureReason",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Reason for the last execution failure",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "randomizeExecution",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Current status of the scheduled action",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "updatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When the scheduled action was last updated",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("subjectReviewState"),
                ::jacquard_lexicon::lexicon::LexUserType::String(::jacquard_lexicon::lexicon::LexString {
                    description: None,
                    format: None,
                    default: None,
                    min_length: None,
                    max_length: None,
                    min_graphemes: None,
                    max_graphemes: None,
                    r#enum: None,
                    r#const: None,
                    known_values: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("subjectStatusView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("updatedAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("reviewState")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "accountStats",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#accountStats",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "accountStrike",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#accountStrike",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "ageAssuranceState",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Current age assurance state of the subject.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "ageAssuranceUpdatedBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Whether or not the last successful update to age assurance was made by the user or admin.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("appealed"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("comment"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Sticky comment on the subject.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Timestamp referencing the first moderation status impacting event was emitted on the subject",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("hosting"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("#accountHosting"),
                                    ::jacquard_common::CowStr::new_static("#recordHosting")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastAppealedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Timestamp referencing when the author of the subject appealed a moderation action",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastReportedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastReviewedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastReviewedBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "muteReportingUntil",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "muteUntil",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "priorityScore",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: Some(0i64),
                                maximum: Some(100i64),
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "recordsStats",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#recordsStats",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "reviewState",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#subjectReviewState",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("com.atproto.admin.defs#repoRef"),
                                    ::jacquard_common::CowStr::new_static("com.atproto.repo.strongRef"),
                                    ::jacquard_common::CowStr::new_static("chat.bsky.convo.defs#messageRef")
                                ],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectBlobCids",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: Some(
                                        ::jacquard_lexicon::lexicon::LexStringFormat::Cid,
                                    ),
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "subjectRepoHandle",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "suspendUntil",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("tags"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: None,
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "takendown",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "updatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Timestamp referencing when the last update was made to the moderation status of the subject",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("subjectView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Detailed view of a subject. For record subjects, the author's repo and profile will be returned.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subject")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("profile"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![],
                                closed: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("record"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#recordViewDetail",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("repo"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#repoViewDetail",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#subjectStatusView",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "com.atproto.moderation.defs#subjectType",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "timelineEventPlcCreate",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "timelineEventPlcOperation",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "timelineEventPlcTombstone",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Token(::jacquard_lexicon::lexicon::LexToken {
                    description: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("videoDetails"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_common::smol_str::SmolStr::new_static("height"),
                            ::jacquard_common::smol_str::SmolStr::new_static("length")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("height"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("length"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for AccountEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "accountEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct AccountHosting<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deleted_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub status: AccountHostingStatus<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub updated_at: std::option::Option<jacquard_common::types::string::Datetime>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AccountHostingStatus<'a> {
    Takendown,
    Suspended,
    Deleted,
    Deactivated,
    Unknown,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> AccountHostingStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Takendown => "takendown",
            Self::Suspended => "suspended",
            Self::Deleted => "deleted",
            Self::Deactivated => "deactivated",
            Self::Unknown => "unknown",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for AccountHostingStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "takendown" => Self::Takendown,
            "suspended" => Self::Suspended,
            "deleted" => Self::Deleted,
            "deactivated" => Self::Deactivated,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for AccountHostingStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "takendown" => Self::Takendown,
            "suspended" => Self::Suspended,
            "deleted" => Self::Deleted,
            "deactivated" => Self::Deactivated,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for AccountHostingStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for AccountHostingStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for AccountHostingStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for AccountHostingStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for AccountHostingStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for AccountHostingStatus<'_> {
    type Output = AccountHostingStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            AccountHostingStatus::Takendown => AccountHostingStatus::Takendown,
            AccountHostingStatus::Suspended => AccountHostingStatus::Suspended,
            AccountHostingStatus::Deleted => AccountHostingStatus::Deleted,
            AccountHostingStatus::Deactivated => AccountHostingStatus::Deactivated,
            AccountHostingStatus::Unknown => AccountHostingStatus::Unknown,
            AccountHostingStatus::Other(v) => {
                AccountHostingStatus::Other(v.into_static())
            }
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for AccountHosting<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "accountHosting"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Statistics about a particular account subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct AccountStats<'a> {
    /// Total number of appeals against a moderation action on the account
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appeal_count: std::option::Option<i64>,
    /// Number of times the account was escalated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub escalate_count: std::option::Option<i64>,
    /// Total number of reports on the account
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_count: std::option::Option<i64>,
    /// Number of times the account was suspended
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub suspend_count: std::option::Option<i64>,
    /// Number of times the account was taken down
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub takedown_count: std::option::Option<i64>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for AccountStats<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "accountStats"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Strike information for an account
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct AccountStrike<'a> {
    /// Current number of active strikes (excluding expired strikes)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_strike_count: std::option::Option<i64>,
    /// Timestamp of the first strike received
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub first_strike_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Timestamp of the most recent strike received
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_strike_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Total number of strikes ever received (including expired strikes)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_strike_count: std::option::Option<i64>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for AccountStrike<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "accountStrike"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age assurance info coming directly from users. Only works on DID subjects.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct AgeAssuranceEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub access: std::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
    /// The unique identifier for this instance of the age assurance flow, in UUID format.
    #[serde(borrow)]
    pub attempt_id: jacquard_common::CowStr<'a>,
    /// The IP address used when completing the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub complete_ip: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The user agent used when completing the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub complete_ua: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The ISO 3166-1 alpha-2 country code provided when beginning the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub country_code: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The date and time of this write operation.
    pub created_at: jacquard_common::types::string::Datetime,
    /// The IP address used when initiating the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub init_ip: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The user agent used when initiating the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub init_ua: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The ISO 3166-2 region code provided when beginning the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub region_code: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The status of the Age Assurance process.
    #[serde(borrow)]
    pub status: AgeAssuranceEventStatus<'a>,
}

pub mod age_assurance_event_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type CreatedAt;
        type Status;
        type AttemptId;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type CreatedAt = Unset;
        type Status = Unset;
        type AttemptId = Unset;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type CreatedAt = Set<members::created_at>;
        type Status = S::Status;
        type AttemptId = S::AttemptId;
    }
    ///State transition - sets the `status` field to Set
    pub struct SetStatus<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetStatus<S> {}
    impl<S: State> State for SetStatus<S> {
        type CreatedAt = S::CreatedAt;
        type Status = Set<members::status>;
        type AttemptId = S::AttemptId;
    }
    ///State transition - sets the `attempt_id` field to Set
    pub struct SetAttemptId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAttemptId<S> {}
    impl<S: State> State for SetAttemptId<S> {
        type CreatedAt = S::CreatedAt;
        type Status = S::Status;
        type AttemptId = Set<members::attempt_id>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `status` field
        pub struct status(());
        ///Marker type for the `attempt_id` field
        pub struct attempt_id(());
    }
}

/// Builder for constructing an instance of this type
pub struct AgeAssuranceEventBuilder<'a, S: age_assurance_event_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<AgeAssuranceEventStatus<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> AgeAssuranceEvent<'a> {
    /// Create a new builder for this type
    pub fn new() -> AgeAssuranceEventBuilder<'a, age_assurance_event_state::Empty> {
        AgeAssuranceEventBuilder::new()
    }
}

impl<'a> AgeAssuranceEventBuilder<'a, age_assurance_event_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        AgeAssuranceEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `access` field (optional)
    pub fn access(
        mut self,
        value: impl Into<Option<crate::app_bsky::ageassurance::Access<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `access` field to an Option value (optional)
    pub fn maybe_access(
        mut self,
        value: Option<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> AgeAssuranceEventBuilder<'a, S>
where
    S: age_assurance_event_state::State,
    S::AttemptId: age_assurance_event_state::IsUnset,
{
    /// Set the `attemptId` field (required)
    pub fn attempt_id(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> AgeAssuranceEventBuilder<'a, age_assurance_event_state::SetAttemptId<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        AgeAssuranceEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `completeIp` field (optional)
    pub fn complete_ip(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `completeIp` field to an Option value (optional)
    pub fn maybe_complete_ip(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `completeUa` field (optional)
    pub fn complete_ua(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `completeUa` field to an Option value (optional)
    pub fn maybe_complete_ua(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `countryCode` field (optional)
    pub fn country_code(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `countryCode` field to an Option value (optional)
    pub fn maybe_country_code(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S> AgeAssuranceEventBuilder<'a, S>
where
    S: age_assurance_event_state::State,
    S::CreatedAt: age_assurance_event_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> AgeAssuranceEventBuilder<'a, age_assurance_event_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        AgeAssuranceEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `initIp` field (optional)
    pub fn init_ip(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value.into();
        self
    }
    /// Set the `initIp` field to an Option value (optional)
    pub fn maybe_init_ip(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.6 = value;
        self
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `initUa` field (optional)
    pub fn init_ua(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `initUa` field to an Option value (optional)
    pub fn maybe_init_ua(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S: age_assurance_event_state::State> AgeAssuranceEventBuilder<'a, S> {
    /// Set the `regionCode` field (optional)
    pub fn region_code(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value.into();
        self
    }
    /// Set the `regionCode` field to an Option value (optional)
    pub fn maybe_region_code(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value;
        self
    }
}

impl<'a, S> AgeAssuranceEventBuilder<'a, S>
where
    S: age_assurance_event_state::State,
    S::Status: age_assurance_event_state::IsUnset,
{
    /// Set the `status` field (required)
    pub fn status(
        mut self,
        value: impl Into<AgeAssuranceEventStatus<'a>>,
    ) -> AgeAssuranceEventBuilder<'a, age_assurance_event_state::SetStatus<S>> {
        self.__unsafe_private_named.9 = ::core::option::Option::Some(value.into());
        AgeAssuranceEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> AgeAssuranceEventBuilder<'a, S>
where
    S: age_assurance_event_state::State,
    S::CreatedAt: age_assurance_event_state::IsSet,
    S::Status: age_assurance_event_state::IsSet,
    S::AttemptId: age_assurance_event_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> AgeAssuranceEvent<'a> {
        AgeAssuranceEvent {
            access: self.__unsafe_private_named.0,
            attempt_id: self.__unsafe_private_named.1.unwrap(),
            complete_ip: self.__unsafe_private_named.2,
            complete_ua: self.__unsafe_private_named.3,
            country_code: self.__unsafe_private_named.4,
            created_at: self.__unsafe_private_named.5.unwrap(),
            init_ip: self.__unsafe_private_named.6,
            init_ua: self.__unsafe_private_named.7,
            region_code: self.__unsafe_private_named.8,
            status: self.__unsafe_private_named.9.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> AgeAssuranceEvent<'a> {
        AgeAssuranceEvent {
            access: self.__unsafe_private_named.0,
            attempt_id: self.__unsafe_private_named.1.unwrap(),
            complete_ip: self.__unsafe_private_named.2,
            complete_ua: self.__unsafe_private_named.3,
            country_code: self.__unsafe_private_named.4,
            created_at: self.__unsafe_private_named.5.unwrap(),
            init_ip: self.__unsafe_private_named.6,
            init_ua: self.__unsafe_private_named.7,
            region_code: self.__unsafe_private_named.8,
            status: self.__unsafe_private_named.9.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

/// The status of the Age Assurance process.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AgeAssuranceEventStatus<'a> {
    Unknown,
    Pending,
    Assured,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> AgeAssuranceEventStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::Pending => "pending",
            Self::Assured => "assured",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for AgeAssuranceEventStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "unknown" => Self::Unknown,
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for AgeAssuranceEventStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "unknown" => Self::Unknown,
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for AgeAssuranceEventStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for AgeAssuranceEventStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for AgeAssuranceEventStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for AgeAssuranceEventStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for AgeAssuranceEventStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for AgeAssuranceEventStatus<'_> {
    type Output = AgeAssuranceEventStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            AgeAssuranceEventStatus::Unknown => AgeAssuranceEventStatus::Unknown,
            AgeAssuranceEventStatus::Pending => AgeAssuranceEventStatus::Pending,
            AgeAssuranceEventStatus::Assured => AgeAssuranceEventStatus::Assured,
            AgeAssuranceEventStatus::Other(v) => {
                AgeAssuranceEventStatus::Other(v.into_static())
            }
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for AgeAssuranceEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "ageAssuranceEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age assurance status override by moderators. Only works on DID subjects.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct AgeAssuranceOverrideEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub access: std::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
    /// Comment describing the reason for the override.
    #[serde(borrow)]
    pub comment: jacquard_common::CowStr<'a>,
    /// The status to be set for the user decided by a moderator, overriding whatever value the user had previously. Use reset to default to original state.
    #[serde(borrow)]
    pub status: AgeAssuranceOverrideEventStatus<'a>,
}

/// The status to be set for the user decided by a moderator, overriding whatever value the user had previously. Use reset to default to original state.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AgeAssuranceOverrideEventStatus<'a> {
    Assured,
    Reset,
    Blocked,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> AgeAssuranceOverrideEventStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Assured => "assured",
            Self::Reset => "reset",
            Self::Blocked => "blocked",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for AgeAssuranceOverrideEventStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "assured" => Self::Assured,
            "reset" => Self::Reset,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for AgeAssuranceOverrideEventStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "assured" => Self::Assured,
            "reset" => Self::Reset,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for AgeAssuranceOverrideEventStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for AgeAssuranceOverrideEventStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for AgeAssuranceOverrideEventStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for AgeAssuranceOverrideEventStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for AgeAssuranceOverrideEventStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for AgeAssuranceOverrideEventStatus<'_> {
    type Output = AgeAssuranceOverrideEventStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            AgeAssuranceOverrideEventStatus::Assured => {
                AgeAssuranceOverrideEventStatus::Assured
            }
            AgeAssuranceOverrideEventStatus::Reset => {
                AgeAssuranceOverrideEventStatus::Reset
            }
            AgeAssuranceOverrideEventStatus::Blocked => {
                AgeAssuranceOverrideEventStatus::Blocked
            }
            AgeAssuranceOverrideEventStatus::Other(v) => {
                AgeAssuranceOverrideEventStatus::Other(v.into_static())
            }
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for AgeAssuranceOverrideEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "ageAssuranceOverrideEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct BlobView<'a> {
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub details: std::option::Option<BlobViewDetails<'a>>,
    #[serde(borrow)]
    pub mime_type: jacquard_common::CowStr<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub moderation: std::option::Option<crate::tools_ozone::moderation::Moderation<'a>>,
    pub size: i64,
}

pub mod blob_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Size;
        type MimeType;
        type Cid;
        type CreatedAt;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Size = Unset;
        type MimeType = Unset;
        type Cid = Unset;
        type CreatedAt = Unset;
    }
    ///State transition - sets the `size` field to Set
    pub struct SetSize<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSize<S> {}
    impl<S: State> State for SetSize<S> {
        type Size = Set<members::size>;
        type MimeType = S::MimeType;
        type Cid = S::Cid;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `mime_type` field to Set
    pub struct SetMimeType<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetMimeType<S> {}
    impl<S: State> State for SetMimeType<S> {
        type Size = S::Size;
        type MimeType = Set<members::mime_type>;
        type Cid = S::Cid;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `cid` field to Set
    pub struct SetCid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCid<S> {}
    impl<S: State> State for SetCid<S> {
        type Size = S::Size;
        type MimeType = S::MimeType;
        type Cid = Set<members::cid>;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type Size = S::Size;
        type MimeType = S::MimeType;
        type Cid = S::Cid;
        type CreatedAt = Set<members::created_at>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `size` field
        pub struct size(());
        ///Marker type for the `mime_type` field
        pub struct mime_type(());
        ///Marker type for the `cid` field
        pub struct cid(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
    }
}

/// Builder for constructing an instance of this type
pub struct BlobViewBuilder<'a, S: blob_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<BlobViewDetails<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::Moderation<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> BlobView<'a> {
    /// Create a new builder for this type
    pub fn new() -> BlobViewBuilder<'a, blob_view_state::Empty> {
        BlobViewBuilder::new()
    }
}

impl<'a> BlobViewBuilder<'a, blob_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        BlobViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> BlobViewBuilder<'a, S>
where
    S: blob_view_state::State,
    S::Cid: blob_view_state::IsUnset,
{
    /// Set the `cid` field (required)
    pub fn cid(
        mut self,
        value: impl Into<jacquard_common::types::string::Cid<'a>>,
    ) -> BlobViewBuilder<'a, blob_view_state::SetCid<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        BlobViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> BlobViewBuilder<'a, S>
where
    S: blob_view_state::State,
    S::CreatedAt: blob_view_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> BlobViewBuilder<'a, blob_view_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        BlobViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: blob_view_state::State> BlobViewBuilder<'a, S> {
    /// Set the `details` field (optional)
    pub fn details(mut self, value: impl Into<Option<BlobViewDetails<'a>>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `details` field to an Option value (optional)
    pub fn maybe_details(mut self, value: Option<BlobViewDetails<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> BlobViewBuilder<'a, S>
where
    S: blob_view_state::State,
    S::MimeType: blob_view_state::IsUnset,
{
    /// Set the `mimeType` field (required)
    pub fn mime_type(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> BlobViewBuilder<'a, blob_view_state::SetMimeType<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        BlobViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: blob_view_state::State> BlobViewBuilder<'a, S> {
    /// Set the `moderation` field (optional)
    pub fn moderation(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::Moderation<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `moderation` field to an Option value (optional)
    pub fn maybe_moderation(
        mut self,
        value: Option<crate::tools_ozone::moderation::Moderation<'a>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S> BlobViewBuilder<'a, S>
where
    S: blob_view_state::State,
    S::Size: blob_view_state::IsUnset,
{
    /// Set the `size` field (required)
    pub fn size(
        mut self,
        value: impl Into<i64>,
    ) -> BlobViewBuilder<'a, blob_view_state::SetSize<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        BlobViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> BlobViewBuilder<'a, S>
where
    S: blob_view_state::State,
    S::Size: blob_view_state::IsSet,
    S::MimeType: blob_view_state::IsSet,
    S::Cid: blob_view_state::IsSet,
    S::CreatedAt: blob_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> BlobView<'a> {
        BlobView {
            cid: self.__unsafe_private_named.0.unwrap(),
            created_at: self.__unsafe_private_named.1.unwrap(),
            details: self.__unsafe_private_named.2,
            mime_type: self.__unsafe_private_named.3.unwrap(),
            moderation: self.__unsafe_private_named.4,
            size: self.__unsafe_private_named.5.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> BlobView<'a> {
        BlobView {
            cid: self.__unsafe_private_named.0.unwrap(),
            created_at: self.__unsafe_private_named.1.unwrap(),
            details: self.__unsafe_private_named.2,
            mime_type: self.__unsafe_private_named.3.unwrap(),
            moderation: self.__unsafe_private_named.4,
            size: self.__unsafe_private_named.5.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum BlobViewDetails<'a> {
    #[serde(rename = "tools.ozone.moderation.defs#imageDetails")]
    ImageDetails(Box<crate::tools_ozone::moderation::ImageDetails<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#videoDetails")]
    VideoDetails(Box<crate::tools_ozone::moderation::VideoDetails<'a>>),
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for BlobView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "blobView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Logs cancellation of a scheduled takedown action for an account.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct CancelScheduledTakedownEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for CancelScheduledTakedownEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "cancelScheduledTakedownEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct IdentityEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub handle: std::option::Option<jacquard_common::types::string::Handle<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub pds_host: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    pub timestamp: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tombstone: std::option::Option<bool>,
}

pub mod identity_event_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Timestamp;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Timestamp = Unset;
    }
    ///State transition - sets the `timestamp` field to Set
    pub struct SetTimestamp<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetTimestamp<S> {}
    impl<S: State> State for SetTimestamp<S> {
        type Timestamp = Set<members::timestamp>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `timestamp` field
        pub struct timestamp(());
    }
}

/// Builder for constructing an instance of this type
pub struct IdentityEventBuilder<'a, S: identity_event_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Handle<'a>>,
        ::core::option::Option<jacquard_common::types::string::Uri<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<bool>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> IdentityEvent<'a> {
    /// Create a new builder for this type
    pub fn new() -> IdentityEventBuilder<'a, identity_event_state::Empty> {
        IdentityEventBuilder::new()
    }
}

impl<'a> IdentityEventBuilder<'a, identity_event_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        IdentityEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: identity_event_state::State> IdentityEventBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: identity_event_state::State> IdentityEventBuilder<'a, S> {
    /// Set the `handle` field (optional)
    pub fn handle(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Handle<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `handle` field to an Option value (optional)
    pub fn maybe_handle(
        mut self,
        value: Option<jacquard_common::types::string::Handle<'a>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: identity_event_state::State> IdentityEventBuilder<'a, S> {
    /// Set the `pdsHost` field (optional)
    pub fn pds_host(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Uri<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `pdsHost` field to an Option value (optional)
    pub fn maybe_pds_host(
        mut self,
        value: Option<jacquard_common::types::string::Uri<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> IdentityEventBuilder<'a, S>
where
    S: identity_event_state::State,
    S::Timestamp: identity_event_state::IsUnset,
{
    /// Set the `timestamp` field (required)
    pub fn timestamp(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> IdentityEventBuilder<'a, identity_event_state::SetTimestamp<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        IdentityEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: identity_event_state::State> IdentityEventBuilder<'a, S> {
    /// Set the `tombstone` field (optional)
    pub fn tombstone(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `tombstone` field to an Option value (optional)
    pub fn maybe_tombstone(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S> IdentityEventBuilder<'a, S>
where
    S: identity_event_state::State,
    S::Timestamp: identity_event_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> IdentityEvent<'a> {
        IdentityEvent {
            comment: self.__unsafe_private_named.0,
            handle: self.__unsafe_private_named.1,
            pds_host: self.__unsafe_private_named.2,
            timestamp: self.__unsafe_private_named.3.unwrap(),
            tombstone: self.__unsafe_private_named.4,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> IdentityEvent<'a> {
        IdentityEvent {
            comment: self.__unsafe_private_named.0,
            handle: self.__unsafe_private_named.1,
            pds_host: self.__unsafe_private_named.2,
            timestamp: self.__unsafe_private_named.3.unwrap(),
            tombstone: self.__unsafe_private_named.4,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for IdentityEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "identityEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ImageDetails<'a> {
    pub height: i64,
    pub width: i64,
}

pub mod image_details_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Width;
        type Height;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Width = Unset;
        type Height = Unset;
    }
    ///State transition - sets the `width` field to Set
    pub struct SetWidth<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetWidth<S> {}
    impl<S: State> State for SetWidth<S> {
        type Width = Set<members::width>;
        type Height = S::Height;
    }
    ///State transition - sets the `height` field to Set
    pub struct SetHeight<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetHeight<S> {}
    impl<S: State> State for SetHeight<S> {
        type Width = S::Width;
        type Height = Set<members::height>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `width` field
        pub struct width(());
        ///Marker type for the `height` field
        pub struct height(());
    }
}

/// Builder for constructing an instance of this type
pub struct ImageDetailsBuilder<'a, S: image_details_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (::core::option::Option<i64>, ::core::option::Option<i64>),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ImageDetails<'a> {
    /// Create a new builder for this type
    pub fn new() -> ImageDetailsBuilder<'a, image_details_state::Empty> {
        ImageDetailsBuilder::new()
    }
}

impl<'a> ImageDetailsBuilder<'a, image_details_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ImageDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ImageDetailsBuilder<'a, S>
where
    S: image_details_state::State,
    S::Height: image_details_state::IsUnset,
{
    /// Set the `height` field (required)
    pub fn height(
        mut self,
        value: impl Into<i64>,
    ) -> ImageDetailsBuilder<'a, image_details_state::SetHeight<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ImageDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ImageDetailsBuilder<'a, S>
where
    S: image_details_state::State,
    S::Width: image_details_state::IsUnset,
{
    /// Set the `width` field (required)
    pub fn width(
        mut self,
        value: impl Into<i64>,
    ) -> ImageDetailsBuilder<'a, image_details_state::SetWidth<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ImageDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ImageDetailsBuilder<'a, S>
where
    S: image_details_state::State,
    S::Width: image_details_state::IsSet,
    S::Height: image_details_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ImageDetails<'a> {
        ImageDetails {
            height: self.__unsafe_private_named.0.unwrap(),
            width: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ImageDetails<'a> {
        ImageDetails {
            height: self.__unsafe_private_named.0.unwrap(),
            width: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ImageDetails<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "imageDetails"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventAcknowledge<'a> {
    /// If true, all other reports on content authored by this account will be resolved (acknowledged).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acknowledge_account_subjects: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventAcknowledge<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventAcknowledge"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Add a comment to a subject. An empty comment will clear any previously set sticky comment.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventComment<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Make the comment persistent on the subject
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sticky: std::option::Option<bool>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventComment<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventComment"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Divert a record's blobs to a 3rd party service for further scanning/tagging
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventDivert<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventDivert<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventDivert"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Keep a log of outgoing email to a user
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventEmail<'a> {
    /// Additional comment about the outgoing comm.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The content of the email sent to the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub content: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Indicates whether the email was successfully delivered to the user's inbox.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_delivered: std::option::Option<bool>,
    /// Names/Keywords of the policies that necessitated the email.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub policies: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    /// Severity level of the violation. Normally 'sev-1' that adds strike on repeat offense
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub severity_level: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Number of strikes to assign to the user for this violation. Normally 0 as an indicator of a warning and only added as a strike on a repeat offense.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strike_count: std::option::Option<i64>,
    /// When the strike should expire. If not provided, the strike never expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strike_expires_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// The subject line of the email sent to the user.
    #[serde(borrow)]
    pub subject_line: jacquard_common::CowStr<'a>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventEmail<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventEmail"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.policies {
            #[allow(unused_comparisons)]
            if value.len() > 5usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "policies",
                    ),
                    max: 5usize,
                    actual: value.len(),
                });
            }
        }
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventEscalate<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventEscalate<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventEscalate"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Apply/Negate labels on a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventLabel<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub create_label_vals: Vec<jacquard_common::CowStr<'a>>,
    /// Indicates how long the label will remain on the subject. Only applies on labels that are being added.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration_in_hours: std::option::Option<i64>,
    #[serde(borrow)]
    pub negate_label_vals: Vec<jacquard_common::CowStr<'a>>,
}

pub mod mod_event_label_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type CreateLabelVals;
        type NegateLabelVals;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type CreateLabelVals = Unset;
        type NegateLabelVals = Unset;
    }
    ///State transition - sets the `create_label_vals` field to Set
    pub struct SetCreateLabelVals<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreateLabelVals<S> {}
    impl<S: State> State for SetCreateLabelVals<S> {
        type CreateLabelVals = Set<members::create_label_vals>;
        type NegateLabelVals = S::NegateLabelVals;
    }
    ///State transition - sets the `negate_label_vals` field to Set
    pub struct SetNegateLabelVals<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetNegateLabelVals<S> {}
    impl<S: State> State for SetNegateLabelVals<S> {
        type CreateLabelVals = S::CreateLabelVals;
        type NegateLabelVals = Set<members::negate_label_vals>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `create_label_vals` field
        pub struct create_label_vals(());
        ///Marker type for the `negate_label_vals` field
        pub struct negate_label_vals(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventLabelBuilder<'a, S: mod_event_label_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<Vec<jacquard_common::CowStr<'a>>>,
        ::core::option::Option<i64>,
        ::core::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventLabel<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventLabelBuilder<'a, mod_event_label_state::Empty> {
        ModEventLabelBuilder::new()
    }
}

impl<'a> ModEventLabelBuilder<'a, mod_event_label_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventLabelBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_label_state::State> ModEventLabelBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> ModEventLabelBuilder<'a, S>
where
    S: mod_event_label_state::State,
    S::CreateLabelVals: mod_event_label_state::IsUnset,
{
    /// Set the `createLabelVals` field (required)
    pub fn create_label_vals(
        mut self,
        value: impl Into<Vec<jacquard_common::CowStr<'a>>>,
    ) -> ModEventLabelBuilder<'a, mod_event_label_state::SetCreateLabelVals<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ModEventLabelBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_label_state::State> ModEventLabelBuilder<'a, S> {
    /// Set the `durationInHours` field (optional)
    pub fn duration_in_hours(mut self, value: impl Into<Option<i64>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `durationInHours` field to an Option value (optional)
    pub fn maybe_duration_in_hours(mut self, value: Option<i64>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> ModEventLabelBuilder<'a, S>
where
    S: mod_event_label_state::State,
    S::NegateLabelVals: mod_event_label_state::IsUnset,
{
    /// Set the `negateLabelVals` field (required)
    pub fn negate_label_vals(
        mut self,
        value: impl Into<Vec<jacquard_common::CowStr<'a>>>,
    ) -> ModEventLabelBuilder<'a, mod_event_label_state::SetNegateLabelVals<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ModEventLabelBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventLabelBuilder<'a, S>
where
    S: mod_event_label_state::State,
    S::CreateLabelVals: mod_event_label_state::IsSet,
    S::NegateLabelVals: mod_event_label_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventLabel<'a> {
        ModEventLabel {
            comment: self.__unsafe_private_named.0,
            create_label_vals: self.__unsafe_private_named.1.unwrap(),
            duration_in_hours: self.__unsafe_private_named.2,
            negate_label_vals: self.__unsafe_private_named.3.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventLabel<'a> {
        ModEventLabel {
            comment: self.__unsafe_private_named.0,
            create_label_vals: self.__unsafe_private_named.1.unwrap(),
            duration_in_hours: self.__unsafe_private_named.2,
            negate_label_vals: self.__unsafe_private_named.3.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventLabel<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventLabel"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Mute incoming reports on a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventMute<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Indicates how long the subject should remain muted.
    pub duration_in_hours: i64,
}

pub mod mod_event_mute_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type DurationInHours;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type DurationInHours = Unset;
    }
    ///State transition - sets the `duration_in_hours` field to Set
    pub struct SetDurationInHours<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDurationInHours<S> {}
    impl<S: State> State for SetDurationInHours<S> {
        type DurationInHours = Set<members::duration_in_hours>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `duration_in_hours` field
        pub struct duration_in_hours(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventMuteBuilder<'a, S: mod_event_mute_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventMute<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventMuteBuilder<'a, mod_event_mute_state::Empty> {
        ModEventMuteBuilder::new()
    }
}

impl<'a> ModEventMuteBuilder<'a, mod_event_mute_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventMuteBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_mute_state::State> ModEventMuteBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> ModEventMuteBuilder<'a, S>
where
    S: mod_event_mute_state::State,
    S::DurationInHours: mod_event_mute_state::IsUnset,
{
    /// Set the `durationInHours` field (required)
    pub fn duration_in_hours(
        mut self,
        value: impl Into<i64>,
    ) -> ModEventMuteBuilder<'a, mod_event_mute_state::SetDurationInHours<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ModEventMuteBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventMuteBuilder<'a, S>
where
    S: mod_event_mute_state::State,
    S::DurationInHours: mod_event_mute_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventMute<'a> {
        ModEventMute {
            comment: self.__unsafe_private_named.0,
            duration_in_hours: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventMute<'a> {
        ModEventMute {
            comment: self.__unsafe_private_named.0,
            duration_in_hours: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventMute<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventMute"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Mute incoming reports from an account
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventMuteReporter<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Indicates how long the account should remain muted. Falsy value here means a permanent mute.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration_in_hours: std::option::Option<i64>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventMuteReporter<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventMuteReporter"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Set priority score of the subject. Higher score means higher priority.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventPriorityScore<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    pub score: i64,
}

pub mod mod_event_priority_score_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Score;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Score = Unset;
    }
    ///State transition - sets the `score` field to Set
    pub struct SetScore<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetScore<S> {}
    impl<S: State> State for SetScore<S> {
        type Score = Set<members::score>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `score` field
        pub struct score(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventPriorityScoreBuilder<'a, S: mod_event_priority_score_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventPriorityScore<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventPriorityScoreBuilder<
        'a,
        mod_event_priority_score_state::Empty,
    > {
        ModEventPriorityScoreBuilder::new()
    }
}

impl<'a> ModEventPriorityScoreBuilder<'a, mod_event_priority_score_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventPriorityScoreBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_priority_score_state::State> ModEventPriorityScoreBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> ModEventPriorityScoreBuilder<'a, S>
where
    S: mod_event_priority_score_state::State,
    S::Score: mod_event_priority_score_state::IsUnset,
{
    /// Set the `score` field (required)
    pub fn score(
        mut self,
        value: impl Into<i64>,
    ) -> ModEventPriorityScoreBuilder<'a, mod_event_priority_score_state::SetScore<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ModEventPriorityScoreBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventPriorityScoreBuilder<'a, S>
where
    S: mod_event_priority_score_state::State,
    S::Score: mod_event_priority_score_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventPriorityScore<'a> {
        ModEventPriorityScore {
            comment: self.__unsafe_private_named.0,
            score: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventPriorityScore<'a> {
        ModEventPriorityScore {
            comment: self.__unsafe_private_named.0,
            score: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventPriorityScore<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventPriorityScore"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        {
            let value = &self.score;
            if *value > 100i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Maximum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "score",
                    ),
                    max: 100i64,
                    actual: *value,
                });
            }
        }
        {
            let value = &self.score;
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "score",
                    ),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}

/// Report a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventReport<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_reporter_muted: std::option::Option<bool>,
    #[serde(borrow)]
    pub report_type: crate::com_atproto::moderation::ReasonType<'a>,
}

pub mod mod_event_report_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type ReportType;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type ReportType = Unset;
    }
    ///State transition - sets the `report_type` field to Set
    pub struct SetReportType<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetReportType<S> {}
    impl<S: State> State for SetReportType<S> {
        type ReportType = Set<members::report_type>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `report_type` field
        pub struct report_type(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventReportBuilder<'a, S: mod_event_report_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bool>,
        ::core::option::Option<crate::com_atproto::moderation::ReasonType<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventReport<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventReportBuilder<'a, mod_event_report_state::Empty> {
        ModEventReportBuilder::new()
    }
}

impl<'a> ModEventReportBuilder<'a, mod_event_report_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventReportBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_report_state::State> ModEventReportBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: mod_event_report_state::State> ModEventReportBuilder<'a, S> {
    /// Set the `isReporterMuted` field (optional)
    pub fn is_reporter_muted(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `isReporterMuted` field to an Option value (optional)
    pub fn maybe_is_reporter_muted(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> ModEventReportBuilder<'a, S>
where
    S: mod_event_report_state::State,
    S::ReportType: mod_event_report_state::IsUnset,
{
    /// Set the `reportType` field (required)
    pub fn report_type(
        mut self,
        value: impl Into<crate::com_atproto::moderation::ReasonType<'a>>,
    ) -> ModEventReportBuilder<'a, mod_event_report_state::SetReportType<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ModEventReportBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventReportBuilder<'a, S>
where
    S: mod_event_report_state::State,
    S::ReportType: mod_event_report_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventReport<'a> {
        ModEventReport {
            comment: self.__unsafe_private_named.0,
            is_reporter_muted: self.__unsafe_private_named.1,
            report_type: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventReport<'a> {
        ModEventReport {
            comment: self.__unsafe_private_named.0,
            is_reporter_muted: self.__unsafe_private_named.1,
            report_type: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventReport<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventReport"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Resolve appeal on a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventResolveAppeal<'a> {
    /// Describe resolution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventResolveAppeal<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventResolveAppeal"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Revert take down action on a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventReverseTakedown<'a> {
    /// Describe reasoning behind the reversal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Names/Keywords of the policy infraction for which takedown is being reversed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub policies: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    /// Severity level of the violation. Usually set from the last policy infraction's severity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub severity_level: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Number of strikes to subtract from the user's strike count. Usually set from the last policy infraction's severity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strike_count: std::option::Option<i64>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventReverseTakedown<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventReverseTakedown"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.policies {
            #[allow(unused_comparisons)]
            if value.len() > 5usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "policies",
                    ),
                    max: 5usize,
                    actual: value.len(),
                });
            }
        }
        Ok(())
    }
}

/// Add/Remove a tag on a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventTag<'a> {
    /// Tags to be added to the subject. If already exists, won't be duplicated.
    #[serde(borrow)]
    pub add: Vec<jacquard_common::CowStr<'a>>,
    /// Additional comment about added/removed tags.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated.
    #[serde(borrow)]
    pub remove: Vec<jacquard_common::CowStr<'a>>,
}

pub mod mod_event_tag_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Add;
        type Remove;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Add = Unset;
        type Remove = Unset;
    }
    ///State transition - sets the `add` field to Set
    pub struct SetAdd<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAdd<S> {}
    impl<S: State> State for SetAdd<S> {
        type Add = Set<members::add>;
        type Remove = S::Remove;
    }
    ///State transition - sets the `remove` field to Set
    pub struct SetRemove<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRemove<S> {}
    impl<S: State> State for SetRemove<S> {
        type Add = S::Add;
        type Remove = Set<members::remove>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `add` field
        pub struct add(());
        ///Marker type for the `remove` field
        pub struct remove(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventTagBuilder<'a, S: mod_event_tag_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<Vec<jacquard_common::CowStr<'a>>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventTag<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventTagBuilder<'a, mod_event_tag_state::Empty> {
        ModEventTagBuilder::new()
    }
}

impl<'a> ModEventTagBuilder<'a, mod_event_tag_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventTagBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventTagBuilder<'a, S>
where
    S: mod_event_tag_state::State,
    S::Add: mod_event_tag_state::IsUnset,
{
    /// Set the `add` field (required)
    pub fn add(
        mut self,
        value: impl Into<Vec<jacquard_common::CowStr<'a>>>,
    ) -> ModEventTagBuilder<'a, mod_event_tag_state::SetAdd<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ModEventTagBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_tag_state::State> ModEventTagBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> ModEventTagBuilder<'a, S>
where
    S: mod_event_tag_state::State,
    S::Remove: mod_event_tag_state::IsUnset,
{
    /// Set the `remove` field (required)
    pub fn remove(
        mut self,
        value: impl Into<Vec<jacquard_common::CowStr<'a>>>,
    ) -> ModEventTagBuilder<'a, mod_event_tag_state::SetRemove<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ModEventTagBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventTagBuilder<'a, S>
where
    S: mod_event_tag_state::State,
    S::Add: mod_event_tag_state::IsSet,
    S::Remove: mod_event_tag_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventTag<'a> {
        ModEventTag {
            add: self.__unsafe_private_named.0.unwrap(),
            comment: self.__unsafe_private_named.1,
            remove: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventTag<'a> {
        ModEventTag {
            add: self.__unsafe_private_named.0.unwrap(),
            comment: self.__unsafe_private_named.1,
            remove: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventTag<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventTag"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Take down a subject permanently or temporarily
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventTakedown<'a> {
    /// If true, all other reports on content authored by this account will be resolved (acknowledged).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acknowledge_account_subjects: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Indicates how long the takedown should be in effect before automatically expiring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration_in_hours: std::option::Option<i64>,
    /// Names/Keywords of the policies that drove the decision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub policies: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    /// Severity level of the violation (e.g., 'sev-0', 'sev-1', 'sev-2', etc.).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub severity_level: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Number of strikes to assign to the user for this violation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strike_count: std::option::Option<i64>,
    /// When the strike should expire. If not provided, the strike never expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strike_expires_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// List of services where the takedown should be applied. If empty or not provided, takedown is applied on all configured services.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub target_services: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventTakedown<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventTakedown"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.policies {
            #[allow(unused_comparisons)]
            if value.len() > 5usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "policies",
                    ),
                    max: 5usize,
                    actual: value.len(),
                });
            }
        }
        Ok(())
    }
}

/// Unmute action on a subject
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventUnmute<'a> {
    /// Describe reasoning behind the reversal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventUnmute<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventUnmute"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Unmute incoming reports from an account
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventUnmuteReporter<'a> {
    /// Describe reasoning behind the reversal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventUnmuteReporter<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventUnmuteReporter"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventView<'a> {
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(borrow)]
    pub created_by: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub creator_handle: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub event: ModEventViewEvent<'a>,
    pub id: i64,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub mod_tool: std::option::Option<crate::tools_ozone::moderation::ModTool<'a>>,
    #[serde(borrow)]
    pub subject: ModEventViewSubject<'a>,
    #[serde(borrow)]
    pub subject_blob_cids: Vec<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_handle: std::option::Option<jacquard_common::CowStr<'a>>,
}

pub mod mod_event_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type SubjectBlobCids;
        type CreatedBy;
        type CreatedAt;
        type Id;
        type Event;
        type Subject;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type SubjectBlobCids = Unset;
        type CreatedBy = Unset;
        type CreatedAt = Unset;
        type Id = Unset;
        type Event = Unset;
        type Subject = Unset;
    }
    ///State transition - sets the `subject_blob_cids` field to Set
    pub struct SetSubjectBlobCids<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubjectBlobCids<S> {}
    impl<S: State> State for SetSubjectBlobCids<S> {
        type SubjectBlobCids = Set<members::subject_blob_cids>;
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Event = S::Event;
        type Subject = S::Subject;
    }
    ///State transition - sets the `created_by` field to Set
    pub struct SetCreatedBy<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedBy<S> {}
    impl<S: State> State for SetCreatedBy<S> {
        type SubjectBlobCids = S::SubjectBlobCids;
        type CreatedBy = Set<members::created_by>;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Event = S::Event;
        type Subject = S::Subject;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type SubjectBlobCids = S::SubjectBlobCids;
        type CreatedBy = S::CreatedBy;
        type CreatedAt = Set<members::created_at>;
        type Id = S::Id;
        type Event = S::Event;
        type Subject = S::Subject;
    }
    ///State transition - sets the `id` field to Set
    pub struct SetId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetId<S> {}
    impl<S: State> State for SetId<S> {
        type SubjectBlobCids = S::SubjectBlobCids;
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = Set<members::id>;
        type Event = S::Event;
        type Subject = S::Subject;
    }
    ///State transition - sets the `event` field to Set
    pub struct SetEvent<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEvent<S> {}
    impl<S: State> State for SetEvent<S> {
        type SubjectBlobCids = S::SubjectBlobCids;
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Event = Set<members::event>;
        type Subject = S::Subject;
    }
    ///State transition - sets the `subject` field to Set
    pub struct SetSubject<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubject<S> {}
    impl<S: State> State for SetSubject<S> {
        type SubjectBlobCids = S::SubjectBlobCids;
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Event = S::Event;
        type Subject = Set<members::subject>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `subject_blob_cids` field
        pub struct subject_blob_cids(());
        ///Marker type for the `created_by` field
        pub struct created_by(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `id` field
        pub struct id(());
        ///Marker type for the `event` field
        pub struct event(());
        ///Marker type for the `subject` field
        pub struct subject(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventViewBuilder<'a, S: mod_event_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<ModEventViewEvent<'a>>,
        ::core::option::Option<i64>,
        ::core::option::Option<crate::tools_ozone::moderation::ModTool<'a>>,
        ::core::option::Option<ModEventViewSubject<'a>>,
        ::core::option::Option<Vec<jacquard_common::CowStr<'a>>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventView<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventViewBuilder<'a, mod_event_view_state::Empty> {
        ModEventViewBuilder::new()
    }
}

impl<'a> ModEventViewBuilder<'a, mod_event_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::CreatedAt: mod_event_view_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> ModEventViewBuilder<'a, mod_event_view_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::CreatedBy: mod_event_view_state::IsUnset,
{
    /// Set the `createdBy` field (required)
    pub fn created_by(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> ModEventViewBuilder<'a, mod_event_view_state::SetCreatedBy<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_view_state::State> ModEventViewBuilder<'a, S> {
    /// Set the `creatorHandle` field (optional)
    pub fn creator_handle(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `creatorHandle` field to an Option value (optional)
    pub fn maybe_creator_handle(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::Event: mod_event_view_state::IsUnset,
{
    /// Set the `event` field (required)
    pub fn event(
        mut self,
        value: impl Into<ModEventViewEvent<'a>>,
    ) -> ModEventViewBuilder<'a, mod_event_view_state::SetEvent<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::Id: mod_event_view_state::IsUnset,
{
    /// Set the `id` field (required)
    pub fn id(
        mut self,
        value: impl Into<i64>,
    ) -> ModEventViewBuilder<'a, mod_event_view_state::SetId<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_view_state::State> ModEventViewBuilder<'a, S> {
    /// Set the `modTool` field (optional)
    pub fn mod_tool(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::ModTool<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `modTool` field to an Option value (optional)
    pub fn maybe_mod_tool(
        mut self,
        value: Option<crate::tools_ozone::moderation::ModTool<'a>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::Subject: mod_event_view_state::IsUnset,
{
    /// Set the `subject` field (required)
    pub fn subject(
        mut self,
        value: impl Into<ModEventViewSubject<'a>>,
    ) -> ModEventViewBuilder<'a, mod_event_view_state::SetSubject<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::SubjectBlobCids: mod_event_view_state::IsUnset,
{
    /// Set the `subjectBlobCids` field (required)
    pub fn subject_blob_cids(
        mut self,
        value: impl Into<Vec<jacquard_common::CowStr<'a>>>,
    ) -> ModEventViewBuilder<'a, mod_event_view_state::SetSubjectBlobCids<S>> {
        self.__unsafe_private_named.7 = ::core::option::Option::Some(value.into());
        ModEventViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_view_state::State> ModEventViewBuilder<'a, S> {
    /// Set the `subjectHandle` field (optional)
    pub fn subject_handle(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value.into();
        self
    }
    /// Set the `subjectHandle` field to an Option value (optional)
    pub fn maybe_subject_handle(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value;
        self
    }
}

impl<'a, S> ModEventViewBuilder<'a, S>
where
    S: mod_event_view_state::State,
    S::SubjectBlobCids: mod_event_view_state::IsSet,
    S::CreatedBy: mod_event_view_state::IsSet,
    S::CreatedAt: mod_event_view_state::IsSet,
    S::Id: mod_event_view_state::IsSet,
    S::Event: mod_event_view_state::IsSet,
    S::Subject: mod_event_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventView<'a> {
        ModEventView {
            created_at: self.__unsafe_private_named.0.unwrap(),
            created_by: self.__unsafe_private_named.1.unwrap(),
            creator_handle: self.__unsafe_private_named.2,
            event: self.__unsafe_private_named.3.unwrap(),
            id: self.__unsafe_private_named.4.unwrap(),
            mod_tool: self.__unsafe_private_named.5,
            subject: self.__unsafe_private_named.6.unwrap(),
            subject_blob_cids: self.__unsafe_private_named.7.unwrap(),
            subject_handle: self.__unsafe_private_named.8,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventView<'a> {
        ModEventView {
            created_at: self.__unsafe_private_named.0.unwrap(),
            created_by: self.__unsafe_private_named.1.unwrap(),
            creator_handle: self.__unsafe_private_named.2,
            event: self.__unsafe_private_named.3.unwrap(),
            id: self.__unsafe_private_named.4.unwrap(),
            mod_tool: self.__unsafe_private_named.5,
            subject: self.__unsafe_private_named.6.unwrap(),
            subject_blob_cids: self.__unsafe_private_named.7.unwrap(),
            subject_handle: self.__unsafe_private_named.8,
            extra_data: Some(extra_data),
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewEvent<'a> {
    #[serde(rename = "tools.ozone.moderation.defs#modEventTakedown")]
    ModEventTakedown(Box<crate::tools_ozone::moderation::ModEventTakedown<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventReverseTakedown")]
    ModEventReverseTakedown(
        Box<crate::tools_ozone::moderation::ModEventReverseTakedown<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#modEventComment")]
    ModEventComment(Box<crate::tools_ozone::moderation::ModEventComment<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventReport")]
    ModEventReport(Box<crate::tools_ozone::moderation::ModEventReport<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventLabel")]
    ModEventLabel(Box<crate::tools_ozone::moderation::ModEventLabel<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventAcknowledge")]
    ModEventAcknowledge(Box<crate::tools_ozone::moderation::ModEventAcknowledge<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventEscalate")]
    ModEventEscalate(Box<crate::tools_ozone::moderation::ModEventEscalate<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventMute")]
    ModEventMute(Box<crate::tools_ozone::moderation::ModEventMute<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventUnmute")]
    ModEventUnmute(Box<crate::tools_ozone::moderation::ModEventUnmute<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventMuteReporter")]
    ModEventMuteReporter(Box<crate::tools_ozone::moderation::ModEventMuteReporter<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventUnmuteReporter")]
    ModEventUnmuteReporter(
        Box<crate::tools_ozone::moderation::ModEventUnmuteReporter<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#modEventEmail")]
    ModEventEmail(Box<crate::tools_ozone::moderation::ModEventEmail<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventResolveAppeal")]
    ModEventResolveAppeal(
        Box<crate::tools_ozone::moderation::ModEventResolveAppeal<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#modEventDivert")]
    ModEventDivert(Box<crate::tools_ozone::moderation::ModEventDivert<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventTag")]
    ModEventTag(Box<crate::tools_ozone::moderation::ModEventTag<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#accountEvent")]
    AccountEvent(Box<crate::tools_ozone::moderation::AccountEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#identityEvent")]
    IdentityEvent(Box<crate::tools_ozone::moderation::IdentityEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#recordEvent")]
    RecordEvent(Box<crate::tools_ozone::moderation::RecordEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventPriorityScore")]
    ModEventPriorityScore(
        Box<crate::tools_ozone::moderation::ModEventPriorityScore<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#ageAssuranceEvent")]
    AgeAssuranceEvent(Box<crate::tools_ozone::moderation::AgeAssuranceEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#ageAssuranceOverrideEvent")]
    AgeAssuranceOverrideEvent(
        Box<crate::tools_ozone::moderation::AgeAssuranceOverrideEvent<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#revokeAccountCredentialsEvent")]
    RevokeAccountCredentialsEvent(
        Box<crate::tools_ozone::moderation::RevokeAccountCredentialsEvent<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#scheduleTakedownEvent")]
    ScheduleTakedownEvent(
        Box<crate::tools_ozone::moderation::ScheduleTakedownEvent<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#cancelScheduledTakedownEvent")]
    CancelScheduledTakedownEvent(
        Box<crate::tools_ozone::moderation::CancelScheduledTakedownEvent<'a>>,
    ),
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewSubject<'a> {
    #[serde(rename = "com.atproto.admin.defs#repoRef")]
    RepoRef(Box<crate::com_atproto::admin::RepoRef<'a>>),
    #[serde(rename = "com.atproto.repo.strongRef")]
    StrongRef(Box<crate::com_atproto::repo::strong_ref::StrongRef<'a>>),
    #[serde(rename = "chat.bsky.convo.defs#messageRef")]
    MessageRef(Box<crate::chat_bsky::convo::MessageRef<'a>>),
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ModEventViewDetail<'a> {
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(borrow)]
    pub created_by: jacquard_common::types::string::Did<'a>,
    #[serde(borrow)]
    pub event: ModEventViewDetailEvent<'a>,
    pub id: i64,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub mod_tool: std::option::Option<crate::tools_ozone::moderation::ModTool<'a>>,
    #[serde(borrow)]
    pub subject: ModEventViewDetailSubject<'a>,
    #[serde(borrow)]
    pub subject_blobs: Vec<crate::tools_ozone::moderation::BlobView<'a>>,
}

pub mod mod_event_view_detail_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type CreatedBy;
        type CreatedAt;
        type Id;
        type Subject;
        type Event;
        type SubjectBlobs;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type CreatedBy = Unset;
        type CreatedAt = Unset;
        type Id = Unset;
        type Subject = Unset;
        type Event = Unset;
        type SubjectBlobs = Unset;
    }
    ///State transition - sets the `created_by` field to Set
    pub struct SetCreatedBy<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedBy<S> {}
    impl<S: State> State for SetCreatedBy<S> {
        type CreatedBy = Set<members::created_by>;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Subject = S::Subject;
        type Event = S::Event;
        type SubjectBlobs = S::SubjectBlobs;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = Set<members::created_at>;
        type Id = S::Id;
        type Subject = S::Subject;
        type Event = S::Event;
        type SubjectBlobs = S::SubjectBlobs;
    }
    ///State transition - sets the `id` field to Set
    pub struct SetId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetId<S> {}
    impl<S: State> State for SetId<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = Set<members::id>;
        type Subject = S::Subject;
        type Event = S::Event;
        type SubjectBlobs = S::SubjectBlobs;
    }
    ///State transition - sets the `subject` field to Set
    pub struct SetSubject<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubject<S> {}
    impl<S: State> State for SetSubject<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Subject = Set<members::subject>;
        type Event = S::Event;
        type SubjectBlobs = S::SubjectBlobs;
    }
    ///State transition - sets the `event` field to Set
    pub struct SetEvent<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEvent<S> {}
    impl<S: State> State for SetEvent<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Subject = S::Subject;
        type Event = Set<members::event>;
        type SubjectBlobs = S::SubjectBlobs;
    }
    ///State transition - sets the `subject_blobs` field to Set
    pub struct SetSubjectBlobs<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubjectBlobs<S> {}
    impl<S: State> State for SetSubjectBlobs<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Id = S::Id;
        type Subject = S::Subject;
        type Event = S::Event;
        type SubjectBlobs = Set<members::subject_blobs>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `created_by` field
        pub struct created_by(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `id` field
        pub struct id(());
        ///Marker type for the `subject` field
        pub struct subject(());
        ///Marker type for the `event` field
        pub struct event(());
        ///Marker type for the `subject_blobs` field
        pub struct subject_blobs(());
    }
}

/// Builder for constructing an instance of this type
pub struct ModEventViewDetailBuilder<'a, S: mod_event_view_detail_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<ModEventViewDetailEvent<'a>>,
        ::core::option::Option<i64>,
        ::core::option::Option<crate::tools_ozone::moderation::ModTool<'a>>,
        ::core::option::Option<ModEventViewDetailSubject<'a>>,
        ::core::option::Option<Vec<crate::tools_ozone::moderation::BlobView<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ModEventViewDetail<'a> {
    /// Create a new builder for this type
    pub fn new() -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::Empty> {
        ModEventViewDetailBuilder::new()
    }
}

impl<'a> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::CreatedAt: mod_event_view_detail_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::CreatedBy: mod_event_view_detail_state::IsUnset,
{
    /// Set the `createdBy` field (required)
    pub fn created_by(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::SetCreatedBy<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::Event: mod_event_view_detail_state::IsUnset,
{
    /// Set the `event` field (required)
    pub fn event(
        mut self,
        value: impl Into<ModEventViewDetailEvent<'a>>,
    ) -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::SetEvent<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::Id: mod_event_view_detail_state::IsUnset,
{
    /// Set the `id` field (required)
    pub fn id(
        mut self,
        value: impl Into<i64>,
    ) -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::SetId<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: mod_event_view_detail_state::State> ModEventViewDetailBuilder<'a, S> {
    /// Set the `modTool` field (optional)
    pub fn mod_tool(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::ModTool<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `modTool` field to an Option value (optional)
    pub fn maybe_mod_tool(
        mut self,
        value: Option<crate::tools_ozone::moderation::ModTool<'a>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::Subject: mod_event_view_detail_state::IsUnset,
{
    /// Set the `subject` field (required)
    pub fn subject(
        mut self,
        value: impl Into<ModEventViewDetailSubject<'a>>,
    ) -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::SetSubject<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::SubjectBlobs: mod_event_view_detail_state::IsUnset,
{
    /// Set the `subjectBlobs` field (required)
    pub fn subject_blobs(
        mut self,
        value: impl Into<Vec<crate::tools_ozone::moderation::BlobView<'a>>>,
    ) -> ModEventViewDetailBuilder<'a, mod_event_view_detail_state::SetSubjectBlobs<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        ModEventViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ModEventViewDetailBuilder<'a, S>
where
    S: mod_event_view_detail_state::State,
    S::CreatedBy: mod_event_view_detail_state::IsSet,
    S::CreatedAt: mod_event_view_detail_state::IsSet,
    S::Id: mod_event_view_detail_state::IsSet,
    S::Subject: mod_event_view_detail_state::IsSet,
    S::Event: mod_event_view_detail_state::IsSet,
    S::SubjectBlobs: mod_event_view_detail_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ModEventViewDetail<'a> {
        ModEventViewDetail {
            created_at: self.__unsafe_private_named.0.unwrap(),
            created_by: self.__unsafe_private_named.1.unwrap(),
            event: self.__unsafe_private_named.2.unwrap(),
            id: self.__unsafe_private_named.3.unwrap(),
            mod_tool: self.__unsafe_private_named.4,
            subject: self.__unsafe_private_named.5.unwrap(),
            subject_blobs: self.__unsafe_private_named.6.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ModEventViewDetail<'a> {
        ModEventViewDetail {
            created_at: self.__unsafe_private_named.0.unwrap(),
            created_by: self.__unsafe_private_named.1.unwrap(),
            event: self.__unsafe_private_named.2.unwrap(),
            id: self.__unsafe_private_named.3.unwrap(),
            mod_tool: self.__unsafe_private_named.4,
            subject: self.__unsafe_private_named.5.unwrap(),
            subject_blobs: self.__unsafe_private_named.6.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewDetailEvent<'a> {
    #[serde(rename = "tools.ozone.moderation.defs#modEventTakedown")]
    ModEventTakedown(Box<crate::tools_ozone::moderation::ModEventTakedown<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventReverseTakedown")]
    ModEventReverseTakedown(
        Box<crate::tools_ozone::moderation::ModEventReverseTakedown<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#modEventComment")]
    ModEventComment(Box<crate::tools_ozone::moderation::ModEventComment<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventReport")]
    ModEventReport(Box<crate::tools_ozone::moderation::ModEventReport<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventLabel")]
    ModEventLabel(Box<crate::tools_ozone::moderation::ModEventLabel<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventAcknowledge")]
    ModEventAcknowledge(Box<crate::tools_ozone::moderation::ModEventAcknowledge<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventEscalate")]
    ModEventEscalate(Box<crate::tools_ozone::moderation::ModEventEscalate<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventMute")]
    ModEventMute(Box<crate::tools_ozone::moderation::ModEventMute<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventUnmute")]
    ModEventUnmute(Box<crate::tools_ozone::moderation::ModEventUnmute<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventMuteReporter")]
    ModEventMuteReporter(Box<crate::tools_ozone::moderation::ModEventMuteReporter<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventUnmuteReporter")]
    ModEventUnmuteReporter(
        Box<crate::tools_ozone::moderation::ModEventUnmuteReporter<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#modEventEmail")]
    ModEventEmail(Box<crate::tools_ozone::moderation::ModEventEmail<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventResolveAppeal")]
    ModEventResolveAppeal(
        Box<crate::tools_ozone::moderation::ModEventResolveAppeal<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#modEventDivert")]
    ModEventDivert(Box<crate::tools_ozone::moderation::ModEventDivert<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventTag")]
    ModEventTag(Box<crate::tools_ozone::moderation::ModEventTag<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#accountEvent")]
    AccountEvent(Box<crate::tools_ozone::moderation::AccountEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#identityEvent")]
    IdentityEvent(Box<crate::tools_ozone::moderation::IdentityEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#recordEvent")]
    RecordEvent(Box<crate::tools_ozone::moderation::RecordEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#modEventPriorityScore")]
    ModEventPriorityScore(
        Box<crate::tools_ozone::moderation::ModEventPriorityScore<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#ageAssuranceEvent")]
    AgeAssuranceEvent(Box<crate::tools_ozone::moderation::AgeAssuranceEvent<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#ageAssuranceOverrideEvent")]
    AgeAssuranceOverrideEvent(
        Box<crate::tools_ozone::moderation::AgeAssuranceOverrideEvent<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#revokeAccountCredentialsEvent")]
    RevokeAccountCredentialsEvent(
        Box<crate::tools_ozone::moderation::RevokeAccountCredentialsEvent<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#scheduleTakedownEvent")]
    ScheduleTakedownEvent(
        Box<crate::tools_ozone::moderation::ScheduleTakedownEvent<'a>>,
    ),
    #[serde(rename = "tools.ozone.moderation.defs#cancelScheduledTakedownEvent")]
    CancelScheduledTakedownEvent(
        Box<crate::tools_ozone::moderation::CancelScheduledTakedownEvent<'a>>,
    ),
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewDetailSubject<'a> {
    #[serde(rename = "tools.ozone.moderation.defs#repoView")]
    RepoView(Box<crate::tools_ozone::moderation::RepoView<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#repoViewNotFound")]
    RepoViewNotFound(Box<crate::tools_ozone::moderation::RepoViewNotFound<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#recordView")]
    RecordView(Box<crate::tools_ozone::moderation::RecordView<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#recordViewNotFound")]
    RecordViewNotFound(Box<crate::tools_ozone::moderation::RecordViewNotFound<'a>>),
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModEventViewDetail<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modEventViewDetail"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Moderation tool information for tracing the source of the action
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModTool<'a> {
    /// Additional arbitrary metadata about the source
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub meta: std::option::Option<jacquard_common::types::value::Data<'a>>,
    /// Name/identifier of the source (e.g., 'automod', 'ozone/workspace')
    #[serde(borrow)]
    pub name: jacquard_common::CowStr<'a>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModTool<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "modTool"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct Moderation<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_status: std::option::Option<
        crate::tools_ozone::moderation::SubjectStatusView<'a>,
    >,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Moderation<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "moderation"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ModerationDetail<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_status: std::option::Option<
        crate::tools_ozone::moderation::SubjectStatusView<'a>,
    >,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ModerationDetail<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "moderationDetail"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RecordEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub op: RecordEventOp<'a>,
    pub timestamp: jacquard_common::types::string::Datetime,
}

pub mod record_event_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Op;
        type Timestamp;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Op = Unset;
        type Timestamp = Unset;
    }
    ///State transition - sets the `op` field to Set
    pub struct SetOp<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetOp<S> {}
    impl<S: State> State for SetOp<S> {
        type Op = Set<members::op>;
        type Timestamp = S::Timestamp;
    }
    ///State transition - sets the `timestamp` field to Set
    pub struct SetTimestamp<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetTimestamp<S> {}
    impl<S: State> State for SetTimestamp<S> {
        type Op = S::Op;
        type Timestamp = Set<members::timestamp>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `op` field
        pub struct op(());
        ///Marker type for the `timestamp` field
        pub struct timestamp(());
    }
}

/// Builder for constructing an instance of this type
pub struct RecordEventBuilder<'a, S: record_event_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<RecordEventOp<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RecordEvent<'a> {
    /// Create a new builder for this type
    pub fn new() -> RecordEventBuilder<'a, record_event_state::Empty> {
        RecordEventBuilder::new()
    }
}

impl<'a> RecordEventBuilder<'a, record_event_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RecordEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: record_event_state::State> RecordEventBuilder<'a, S> {
    /// Set the `cid` field (optional)
    pub fn cid(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Cid<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `cid` field to an Option value (optional)
    pub fn maybe_cid(
        mut self,
        value: Option<jacquard_common::types::string::Cid<'a>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: record_event_state::State> RecordEventBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> RecordEventBuilder<'a, S>
where
    S: record_event_state::State,
    S::Op: record_event_state::IsUnset,
{
    /// Set the `op` field (required)
    pub fn op(
        mut self,
        value: impl Into<RecordEventOp<'a>>,
    ) -> RecordEventBuilder<'a, record_event_state::SetOp<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        RecordEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordEventBuilder<'a, S>
where
    S: record_event_state::State,
    S::Timestamp: record_event_state::IsUnset,
{
    /// Set the `timestamp` field (required)
    pub fn timestamp(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> RecordEventBuilder<'a, record_event_state::SetTimestamp<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        RecordEventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordEventBuilder<'a, S>
where
    S: record_event_state::State,
    S::Op: record_event_state::IsSet,
    S::Timestamp: record_event_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RecordEvent<'a> {
        RecordEvent {
            cid: self.__unsafe_private_named.0,
            comment: self.__unsafe_private_named.1,
            op: self.__unsafe_private_named.2.unwrap(),
            timestamp: self.__unsafe_private_named.3.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RecordEvent<'a> {
        RecordEvent {
            cid: self.__unsafe_private_named.0,
            comment: self.__unsafe_private_named.1,
            op: self.__unsafe_private_named.2.unwrap(),
            timestamp: self.__unsafe_private_named.3.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecordEventOp<'a> {
    Create,
    Update,
    Delete,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> RecordEventOp<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::Update => "update",
            Self::Delete => "delete",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for RecordEventOp<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "create" => Self::Create,
            "update" => Self::Update,
            "delete" => Self::Delete,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for RecordEventOp<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "create" => Self::Create,
            "update" => Self::Update,
            "delete" => Self::Delete,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for RecordEventOp<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for RecordEventOp<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for RecordEventOp<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for RecordEventOp<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for RecordEventOp<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for RecordEventOp<'_> {
    type Output = RecordEventOp<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            RecordEventOp::Create => RecordEventOp::Create,
            RecordEventOp::Update => RecordEventOp::Update,
            RecordEventOp::Delete => RecordEventOp::Delete,
            RecordEventOp::Other(v) => RecordEventOp::Other(v.into_static()),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecordEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "recordEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct RecordHosting<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deleted_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub status: RecordHostingStatus<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub updated_at: std::option::Option<jacquard_common::types::string::Datetime>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecordHostingStatus<'a> {
    Deleted,
    Unknown,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> RecordHostingStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Deleted => "deleted",
            Self::Unknown => "unknown",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for RecordHostingStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "deleted" => Self::Deleted,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for RecordHostingStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "deleted" => Self::Deleted,
            "unknown" => Self::Unknown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for RecordHostingStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for RecordHostingStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for RecordHostingStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for RecordHostingStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for RecordHostingStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for RecordHostingStatus<'_> {
    type Output = RecordHostingStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            RecordHostingStatus::Deleted => RecordHostingStatus::Deleted,
            RecordHostingStatus::Unknown => RecordHostingStatus::Unknown,
            RecordHostingStatus::Other(v) => RecordHostingStatus::Other(v.into_static()),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecordHosting<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "recordHosting"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RecordView<'a> {
    #[serde(borrow)]
    pub blob_cids: Vec<jacquard_common::types::string::Cid<'a>>,
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::Moderation<'a>,
    #[serde(borrow)]
    pub repo: crate::tools_ozone::moderation::RepoView<'a>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: jacquard_common::types::value::Data<'a>,
}

pub mod record_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Repo;
        type Uri;
        type Moderation;
        type IndexedAt;
        type Cid;
        type BlobCids;
        type Value;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Repo = Unset;
        type Uri = Unset;
        type Moderation = Unset;
        type IndexedAt = Unset;
        type Cid = Unset;
        type BlobCids = Unset;
        type Value = Unset;
    }
    ///State transition - sets the `repo` field to Set
    pub struct SetRepo<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRepo<S> {}
    impl<S: State> State for SetRepo<S> {
        type Repo = Set<members::repo>;
        type Uri = S::Uri;
        type Moderation = S::Moderation;
        type IndexedAt = S::IndexedAt;
        type Cid = S::Cid;
        type BlobCids = S::BlobCids;
        type Value = S::Value;
    }
    ///State transition - sets the `uri` field to Set
    pub struct SetUri<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUri<S> {}
    impl<S: State> State for SetUri<S> {
        type Repo = S::Repo;
        type Uri = Set<members::uri>;
        type Moderation = S::Moderation;
        type IndexedAt = S::IndexedAt;
        type Cid = S::Cid;
        type BlobCids = S::BlobCids;
        type Value = S::Value;
    }
    ///State transition - sets the `moderation` field to Set
    pub struct SetModeration<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetModeration<S> {}
    impl<S: State> State for SetModeration<S> {
        type Repo = S::Repo;
        type Uri = S::Uri;
        type Moderation = Set<members::moderation>;
        type IndexedAt = S::IndexedAt;
        type Cid = S::Cid;
        type BlobCids = S::BlobCids;
        type Value = S::Value;
    }
    ///State transition - sets the `indexed_at` field to Set
    pub struct SetIndexedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetIndexedAt<S> {}
    impl<S: State> State for SetIndexedAt<S> {
        type Repo = S::Repo;
        type Uri = S::Uri;
        type Moderation = S::Moderation;
        type IndexedAt = Set<members::indexed_at>;
        type Cid = S::Cid;
        type BlobCids = S::BlobCids;
        type Value = S::Value;
    }
    ///State transition - sets the `cid` field to Set
    pub struct SetCid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCid<S> {}
    impl<S: State> State for SetCid<S> {
        type Repo = S::Repo;
        type Uri = S::Uri;
        type Moderation = S::Moderation;
        type IndexedAt = S::IndexedAt;
        type Cid = Set<members::cid>;
        type BlobCids = S::BlobCids;
        type Value = S::Value;
    }
    ///State transition - sets the `blob_cids` field to Set
    pub struct SetBlobCids<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetBlobCids<S> {}
    impl<S: State> State for SetBlobCids<S> {
        type Repo = S::Repo;
        type Uri = S::Uri;
        type Moderation = S::Moderation;
        type IndexedAt = S::IndexedAt;
        type Cid = S::Cid;
        type BlobCids = Set<members::blob_cids>;
        type Value = S::Value;
    }
    ///State transition - sets the `value` field to Set
    pub struct SetValue<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetValue<S> {}
    impl<S: State> State for SetValue<S> {
        type Repo = S::Repo;
        type Uri = S::Uri;
        type Moderation = S::Moderation;
        type IndexedAt = S::IndexedAt;
        type Cid = S::Cid;
        type BlobCids = S::BlobCids;
        type Value = Set<members::value>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `repo` field
        pub struct repo(());
        ///Marker type for the `uri` field
        pub struct uri(());
        ///Marker type for the `moderation` field
        pub struct moderation(());
        ///Marker type for the `indexed_at` field
        pub struct indexed_at(());
        ///Marker type for the `cid` field
        pub struct cid(());
        ///Marker type for the `blob_cids` field
        pub struct blob_cids(());
        ///Marker type for the `value` field
        pub struct value(());
    }
}

/// Builder for constructing an instance of this type
pub struct RecordViewBuilder<'a, S: record_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<Vec<jacquard_common::types::string::Cid<'a>>>,
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<crate::tools_ozone::moderation::Moderation<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::RepoView<'a>>,
        ::core::option::Option<jacquard_common::types::string::AtUri<'a>>,
        ::core::option::Option<jacquard_common::types::value::Data<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RecordView<'a> {
    /// Create a new builder for this type
    pub fn new() -> RecordViewBuilder<'a, record_view_state::Empty> {
        RecordViewBuilder::new()
    }
}

impl<'a> RecordViewBuilder<'a, record_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::BlobCids: record_view_state::IsUnset,
{
    /// Set the `blobCids` field (required)
    pub fn blob_cids(
        mut self,
        value: impl Into<Vec<jacquard_common::types::string::Cid<'a>>>,
    ) -> RecordViewBuilder<'a, record_view_state::SetBlobCids<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::Cid: record_view_state::IsUnset,
{
    /// Set the `cid` field (required)
    pub fn cid(
        mut self,
        value: impl Into<jacquard_common::types::string::Cid<'a>>,
    ) -> RecordViewBuilder<'a, record_view_state::SetCid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::IndexedAt: record_view_state::IsUnset,
{
    /// Set the `indexedAt` field (required)
    pub fn indexed_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> RecordViewBuilder<'a, record_view_state::SetIndexedAt<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::Moderation: record_view_state::IsUnset,
{
    /// Set the `moderation` field (required)
    pub fn moderation(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::Moderation<'a>>,
    ) -> RecordViewBuilder<'a, record_view_state::SetModeration<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::Repo: record_view_state::IsUnset,
{
    /// Set the `repo` field (required)
    pub fn repo(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::RepoView<'a>>,
    ) -> RecordViewBuilder<'a, record_view_state::SetRepo<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::Uri: record_view_state::IsUnset,
{
    /// Set the `uri` field (required)
    pub fn uri(
        mut self,
        value: impl Into<jacquard_common::types::string::AtUri<'a>>,
    ) -> RecordViewBuilder<'a, record_view_state::SetUri<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::Value: record_view_state::IsUnset,
{
    /// Set the `value` field (required)
    pub fn value(
        mut self,
        value: impl Into<jacquard_common::types::value::Data<'a>>,
    ) -> RecordViewBuilder<'a, record_view_state::SetValue<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        RecordViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewBuilder<'a, S>
where
    S: record_view_state::State,
    S::Repo: record_view_state::IsSet,
    S::Uri: record_view_state::IsSet,
    S::Moderation: record_view_state::IsSet,
    S::IndexedAt: record_view_state::IsSet,
    S::Cid: record_view_state::IsSet,
    S::BlobCids: record_view_state::IsSet,
    S::Value: record_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RecordView<'a> {
        RecordView {
            blob_cids: self.__unsafe_private_named.0.unwrap(),
            cid: self.__unsafe_private_named.1.unwrap(),
            indexed_at: self.__unsafe_private_named.2.unwrap(),
            moderation: self.__unsafe_private_named.3.unwrap(),
            repo: self.__unsafe_private_named.4.unwrap(),
            uri: self.__unsafe_private_named.5.unwrap(),
            value: self.__unsafe_private_named.6.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RecordView<'a> {
        RecordView {
            blob_cids: self.__unsafe_private_named.0.unwrap(),
            cid: self.__unsafe_private_named.1.unwrap(),
            indexed_at: self.__unsafe_private_named.2.unwrap(),
            moderation: self.__unsafe_private_named.3.unwrap(),
            repo: self.__unsafe_private_named.4.unwrap(),
            uri: self.__unsafe_private_named.5.unwrap(),
            value: self.__unsafe_private_named.6.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecordView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "recordView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RecordViewDetail<'a> {
    #[serde(borrow)]
    pub blobs: Vec<crate::tools_ozone::moderation::BlobView<'a>>,
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::ModerationDetail<'a>,
    #[serde(borrow)]
    pub repo: crate::tools_ozone::moderation::RepoView<'a>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: jacquard_common::types::value::Data<'a>,
}

pub mod record_view_detail_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Blobs;
        type IndexedAt;
        type Repo;
        type Value;
        type Moderation;
        type Uri;
        type Cid;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Blobs = Unset;
        type IndexedAt = Unset;
        type Repo = Unset;
        type Value = Unset;
        type Moderation = Unset;
        type Uri = Unset;
        type Cid = Unset;
    }
    ///State transition - sets the `blobs` field to Set
    pub struct SetBlobs<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetBlobs<S> {}
    impl<S: State> State for SetBlobs<S> {
        type Blobs = Set<members::blobs>;
        type IndexedAt = S::IndexedAt;
        type Repo = S::Repo;
        type Value = S::Value;
        type Moderation = S::Moderation;
        type Uri = S::Uri;
        type Cid = S::Cid;
    }
    ///State transition - sets the `indexed_at` field to Set
    pub struct SetIndexedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetIndexedAt<S> {}
    impl<S: State> State for SetIndexedAt<S> {
        type Blobs = S::Blobs;
        type IndexedAt = Set<members::indexed_at>;
        type Repo = S::Repo;
        type Value = S::Value;
        type Moderation = S::Moderation;
        type Uri = S::Uri;
        type Cid = S::Cid;
    }
    ///State transition - sets the `repo` field to Set
    pub struct SetRepo<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRepo<S> {}
    impl<S: State> State for SetRepo<S> {
        type Blobs = S::Blobs;
        type IndexedAt = S::IndexedAt;
        type Repo = Set<members::repo>;
        type Value = S::Value;
        type Moderation = S::Moderation;
        type Uri = S::Uri;
        type Cid = S::Cid;
    }
    ///State transition - sets the `value` field to Set
    pub struct SetValue<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetValue<S> {}
    impl<S: State> State for SetValue<S> {
        type Blobs = S::Blobs;
        type IndexedAt = S::IndexedAt;
        type Repo = S::Repo;
        type Value = Set<members::value>;
        type Moderation = S::Moderation;
        type Uri = S::Uri;
        type Cid = S::Cid;
    }
    ///State transition - sets the `moderation` field to Set
    pub struct SetModeration<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetModeration<S> {}
    impl<S: State> State for SetModeration<S> {
        type Blobs = S::Blobs;
        type IndexedAt = S::IndexedAt;
        type Repo = S::Repo;
        type Value = S::Value;
        type Moderation = Set<members::moderation>;
        type Uri = S::Uri;
        type Cid = S::Cid;
    }
    ///State transition - sets the `uri` field to Set
    pub struct SetUri<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUri<S> {}
    impl<S: State> State for SetUri<S> {
        type Blobs = S::Blobs;
        type IndexedAt = S::IndexedAt;
        type Repo = S::Repo;
        type Value = S::Value;
        type Moderation = S::Moderation;
        type Uri = Set<members::uri>;
        type Cid = S::Cid;
    }
    ///State transition - sets the `cid` field to Set
    pub struct SetCid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCid<S> {}
    impl<S: State> State for SetCid<S> {
        type Blobs = S::Blobs;
        type IndexedAt = S::IndexedAt;
        type Repo = S::Repo;
        type Value = S::Value;
        type Moderation = S::Moderation;
        type Uri = S::Uri;
        type Cid = Set<members::cid>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `blobs` field
        pub struct blobs(());
        ///Marker type for the `indexed_at` field
        pub struct indexed_at(());
        ///Marker type for the `repo` field
        pub struct repo(());
        ///Marker type for the `value` field
        pub struct value(());
        ///Marker type for the `moderation` field
        pub struct moderation(());
        ///Marker type for the `uri` field
        pub struct uri(());
        ///Marker type for the `cid` field
        pub struct cid(());
    }
}

/// Builder for constructing an instance of this type
pub struct RecordViewDetailBuilder<'a, S: record_view_detail_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<Vec<crate::tools_ozone::moderation::BlobView<'a>>>,
        ::core::option::Option<jacquard_common::types::string::Cid<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
        ::core::option::Option<crate::tools_ozone::moderation::ModerationDetail<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::RepoView<'a>>,
        ::core::option::Option<jacquard_common::types::string::AtUri<'a>>,
        ::core::option::Option<jacquard_common::types::value::Data<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RecordViewDetail<'a> {
    /// Create a new builder for this type
    pub fn new() -> RecordViewDetailBuilder<'a, record_view_detail_state::Empty> {
        RecordViewDetailBuilder::new()
    }
}

impl<'a> RecordViewDetailBuilder<'a, record_view_detail_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Blobs: record_view_detail_state::IsUnset,
{
    /// Set the `blobs` field (required)
    pub fn blobs(
        mut self,
        value: impl Into<Vec<crate::tools_ozone::moderation::BlobView<'a>>>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetBlobs<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Cid: record_view_detail_state::IsUnset,
{
    /// Set the `cid` field (required)
    pub fn cid(
        mut self,
        value: impl Into<jacquard_common::types::string::Cid<'a>>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetCid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::IndexedAt: record_view_detail_state::IsUnset,
{
    /// Set the `indexedAt` field (required)
    pub fn indexed_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetIndexedAt<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: record_view_detail_state::State> RecordViewDetailBuilder<'a, S> {
    /// Set the `labels` field (optional)
    pub fn labels(
        mut self,
        value: impl Into<Option<Vec<crate::com_atproto::label::Label<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `labels` field to an Option value (optional)
    pub fn maybe_labels(
        mut self,
        value: Option<Vec<crate::com_atproto::label::Label<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Moderation: record_view_detail_state::IsUnset,
{
    /// Set the `moderation` field (required)
    pub fn moderation(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::ModerationDetail<'a>>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetModeration<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Repo: record_view_detail_state::IsUnset,
{
    /// Set the `repo` field (required)
    pub fn repo(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::RepoView<'a>>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetRepo<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Uri: record_view_detail_state::IsUnset,
{
    /// Set the `uri` field (required)
    pub fn uri(
        mut self,
        value: impl Into<jacquard_common::types::string::AtUri<'a>>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetUri<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Value: record_view_detail_state::IsUnset,
{
    /// Set the `value` field (required)
    pub fn value(
        mut self,
        value: impl Into<jacquard_common::types::value::Data<'a>>,
    ) -> RecordViewDetailBuilder<'a, record_view_detail_state::SetValue<S>> {
        self.__unsafe_private_named.7 = ::core::option::Option::Some(value.into());
        RecordViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewDetailBuilder<'a, S>
where
    S: record_view_detail_state::State,
    S::Blobs: record_view_detail_state::IsSet,
    S::IndexedAt: record_view_detail_state::IsSet,
    S::Repo: record_view_detail_state::IsSet,
    S::Value: record_view_detail_state::IsSet,
    S::Moderation: record_view_detail_state::IsSet,
    S::Uri: record_view_detail_state::IsSet,
    S::Cid: record_view_detail_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RecordViewDetail<'a> {
        RecordViewDetail {
            blobs: self.__unsafe_private_named.0.unwrap(),
            cid: self.__unsafe_private_named.1.unwrap(),
            indexed_at: self.__unsafe_private_named.2.unwrap(),
            labels: self.__unsafe_private_named.3,
            moderation: self.__unsafe_private_named.4.unwrap(),
            repo: self.__unsafe_private_named.5.unwrap(),
            uri: self.__unsafe_private_named.6.unwrap(),
            value: self.__unsafe_private_named.7.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RecordViewDetail<'a> {
        RecordViewDetail {
            blobs: self.__unsafe_private_named.0.unwrap(),
            cid: self.__unsafe_private_named.1.unwrap(),
            indexed_at: self.__unsafe_private_named.2.unwrap(),
            labels: self.__unsafe_private_named.3,
            moderation: self.__unsafe_private_named.4.unwrap(),
            repo: self.__unsafe_private_named.5.unwrap(),
            uri: self.__unsafe_private_named.6.unwrap(),
            value: self.__unsafe_private_named.7.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecordViewDetail<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "recordViewDetail"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RecordViewNotFound<'a> {
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
}

pub mod record_view_not_found_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Uri;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Uri = Unset;
    }
    ///State transition - sets the `uri` field to Set
    pub struct SetUri<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUri<S> {}
    impl<S: State> State for SetUri<S> {
        type Uri = Set<members::uri>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `uri` field
        pub struct uri(());
    }
}

/// Builder for constructing an instance of this type
pub struct RecordViewNotFoundBuilder<'a, S: record_view_not_found_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::AtUri<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RecordViewNotFound<'a> {
    /// Create a new builder for this type
    pub fn new() -> RecordViewNotFoundBuilder<'a, record_view_not_found_state::Empty> {
        RecordViewNotFoundBuilder::new()
    }
}

impl<'a> RecordViewNotFoundBuilder<'a, record_view_not_found_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RecordViewNotFoundBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None,),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewNotFoundBuilder<'a, S>
where
    S: record_view_not_found_state::State,
    S::Uri: record_view_not_found_state::IsUnset,
{
    /// Set the `uri` field (required)
    pub fn uri(
        mut self,
        value: impl Into<jacquard_common::types::string::AtUri<'a>>,
    ) -> RecordViewNotFoundBuilder<'a, record_view_not_found_state::SetUri<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        RecordViewNotFoundBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecordViewNotFoundBuilder<'a, S>
where
    S: record_view_not_found_state::State,
    S::Uri: record_view_not_found_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RecordViewNotFound<'a> {
        RecordViewNotFound {
            uri: self.__unsafe_private_named.0.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RecordViewNotFound<'a> {
        RecordViewNotFound {
            uri: self.__unsafe_private_named.0.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecordViewNotFound<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "recordViewNotFound"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Statistics about a set of record subject items
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct RecordsStats<'a> {
    /// Number of items that were appealed at least once
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appealed_count: std::option::Option<i64>,
    /// Number of items that were escalated at least once
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub escalated_count: std::option::Option<i64>,
    /// Number of item currently in "reviewOpen" or "reviewEscalated" state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pending_count: std::option::Option<i64>,
    /// Number of item currently in "reviewNone" or "reviewClosed" state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processed_count: std::option::Option<i64>,
    /// Number of items that were reported at least once
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reported_count: std::option::Option<i64>,
    /// Total number of item in the set
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub subject_count: std::option::Option<i64>,
    /// Number of item currently taken down
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub takendown_count: std::option::Option<i64>,
    /// Cumulative sum of the number of reports on the items in the set
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_reports: std::option::Option<i64>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecordsStats<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "recordsStats"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RepoView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub email: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invite_note: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invited_by: std::option::Option<crate::com_atproto::server::InviteCode<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub invites_disabled: std::option::Option<bool>,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::Moderation<'a>,
    #[serde(borrow)]
    pub related_records: Vec<jacquard_common::types::value::Data<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub threat_signatures: std::option::Option<
        Vec<crate::com_atproto::admin::ThreatSignature<'a>>,
    >,
}

pub mod repo_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type RelatedRecords;
        type Handle;
        type IndexedAt;
        type Moderation;
        type Did;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type RelatedRecords = Unset;
        type Handle = Unset;
        type IndexedAt = Unset;
        type Moderation = Unset;
        type Did = Unset;
    }
    ///State transition - sets the `related_records` field to Set
    pub struct SetRelatedRecords<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRelatedRecords<S> {}
    impl<S: State> State for SetRelatedRecords<S> {
        type RelatedRecords = Set<members::related_records>;
        type Handle = S::Handle;
        type IndexedAt = S::IndexedAt;
        type Moderation = S::Moderation;
        type Did = S::Did;
    }
    ///State transition - sets the `handle` field to Set
    pub struct SetHandle<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetHandle<S> {}
    impl<S: State> State for SetHandle<S> {
        type RelatedRecords = S::RelatedRecords;
        type Handle = Set<members::handle>;
        type IndexedAt = S::IndexedAt;
        type Moderation = S::Moderation;
        type Did = S::Did;
    }
    ///State transition - sets the `indexed_at` field to Set
    pub struct SetIndexedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetIndexedAt<S> {}
    impl<S: State> State for SetIndexedAt<S> {
        type RelatedRecords = S::RelatedRecords;
        type Handle = S::Handle;
        type IndexedAt = Set<members::indexed_at>;
        type Moderation = S::Moderation;
        type Did = S::Did;
    }
    ///State transition - sets the `moderation` field to Set
    pub struct SetModeration<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetModeration<S> {}
    impl<S: State> State for SetModeration<S> {
        type RelatedRecords = S::RelatedRecords;
        type Handle = S::Handle;
        type IndexedAt = S::IndexedAt;
        type Moderation = Set<members::moderation>;
        type Did = S::Did;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type RelatedRecords = S::RelatedRecords;
        type Handle = S::Handle;
        type IndexedAt = S::IndexedAt;
        type Moderation = S::Moderation;
        type Did = Set<members::did>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `related_records` field
        pub struct related_records(());
        ///Marker type for the `handle` field
        pub struct handle(());
        ///Marker type for the `indexed_at` field
        pub struct indexed_at(());
        ///Marker type for the `moderation` field
        pub struct moderation(());
        ///Marker type for the `did` field
        pub struct did(());
    }
}

/// Builder for constructing an instance of this type
pub struct RepoViewBuilder<'a, S: repo_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Handle<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<crate::com_atproto::server::InviteCode<'a>>,
        ::core::option::Option<bool>,
        ::core::option::Option<crate::tools_ozone::moderation::Moderation<'a>>,
        ::core::option::Option<Vec<jacquard_common::types::value::Data<'a>>>,
        ::core::option::Option<Vec<crate::com_atproto::admin::ThreatSignature<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RepoView<'a> {
    /// Create a new builder for this type
    pub fn new() -> RepoViewBuilder<'a, repo_view_state::Empty> {
        RepoViewBuilder::new()
    }
}

impl<'a> RepoViewBuilder<'a, repo_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RepoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_state::State> RepoViewBuilder<'a, S> {
    /// Set the `deactivatedAt` field (optional)
    pub fn deactivated_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `deactivatedAt` field to an Option value (optional)
    pub fn maybe_deactivated_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> RepoViewBuilder<'a, S>
where
    S: repo_view_state::State,
    S::Did: repo_view_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> RepoViewBuilder<'a, repo_view_state::SetDid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RepoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_state::State> RepoViewBuilder<'a, S> {
    /// Set the `email` field (optional)
    pub fn email(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `email` field to an Option value (optional)
    pub fn maybe_email(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> RepoViewBuilder<'a, S>
where
    S: repo_view_state::State,
    S::Handle: repo_view_state::IsUnset,
{
    /// Set the `handle` field (required)
    pub fn handle(
        mut self,
        value: impl Into<jacquard_common::types::string::Handle<'a>>,
    ) -> RepoViewBuilder<'a, repo_view_state::SetHandle<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        RepoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RepoViewBuilder<'a, S>
where
    S: repo_view_state::State,
    S::IndexedAt: repo_view_state::IsUnset,
{
    /// Set the `indexedAt` field (required)
    pub fn indexed_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> RepoViewBuilder<'a, repo_view_state::SetIndexedAt<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        RepoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_state::State> RepoViewBuilder<'a, S> {
    /// Set the `inviteNote` field (optional)
    pub fn invite_note(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `inviteNote` field to an Option value (optional)
    pub fn maybe_invite_note(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S: repo_view_state::State> RepoViewBuilder<'a, S> {
    /// Set the `invitedBy` field (optional)
    pub fn invited_by(
        mut self,
        value: impl Into<Option<crate::com_atproto::server::InviteCode<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value.into();
        self
    }
    /// Set the `invitedBy` field to an Option value (optional)
    pub fn maybe_invited_by(
        mut self,
        value: Option<crate::com_atproto::server::InviteCode<'a>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value;
        self
    }
}

impl<'a, S: repo_view_state::State> RepoViewBuilder<'a, S> {
    /// Set the `invitesDisabled` field (optional)
    pub fn invites_disabled(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `invitesDisabled` field to an Option value (optional)
    pub fn maybe_invites_disabled(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S> RepoViewBuilder<'a, S>
where
    S: repo_view_state::State,
    S::Moderation: repo_view_state::IsUnset,
{
    /// Set the `moderation` field (required)
    pub fn moderation(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::Moderation<'a>>,
    ) -> RepoViewBuilder<'a, repo_view_state::SetModeration<S>> {
        self.__unsafe_private_named.8 = ::core::option::Option::Some(value.into());
        RepoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RepoViewBuilder<'a, S>
where
    S: repo_view_state::State,
    S::RelatedRecords: repo_view_state::IsUnset,
{
    /// Set the `relatedRecords` field (required)
    pub fn related_records(
        mut self,
        value: impl Into<Vec<jacquard_common::types::value::Data<'a>>>,
    ) -> RepoViewBuilder<'a, repo_view_state::SetRelatedRecords<S>> {
        self.__unsafe_private_named.9 = ::core::option::Option::Some(value.into());
        RepoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_state::State> RepoViewBuilder<'a, S> {
    /// Set the `threatSignatures` field (optional)
    pub fn threat_signatures(
        mut self,
        value: impl Into<Option<Vec<crate::com_atproto::admin::ThreatSignature<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.10 = value.into();
        self
    }
    /// Set the `threatSignatures` field to an Option value (optional)
    pub fn maybe_threat_signatures(
        mut self,
        value: Option<Vec<crate::com_atproto::admin::ThreatSignature<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.10 = value;
        self
    }
}

impl<'a, S> RepoViewBuilder<'a, S>
where
    S: repo_view_state::State,
    S::RelatedRecords: repo_view_state::IsSet,
    S::Handle: repo_view_state::IsSet,
    S::IndexedAt: repo_view_state::IsSet,
    S::Moderation: repo_view_state::IsSet,
    S::Did: repo_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RepoView<'a> {
        RepoView {
            deactivated_at: self.__unsafe_private_named.0,
            did: self.__unsafe_private_named.1.unwrap(),
            email: self.__unsafe_private_named.2,
            handle: self.__unsafe_private_named.3.unwrap(),
            indexed_at: self.__unsafe_private_named.4.unwrap(),
            invite_note: self.__unsafe_private_named.5,
            invited_by: self.__unsafe_private_named.6,
            invites_disabled: self.__unsafe_private_named.7,
            moderation: self.__unsafe_private_named.8.unwrap(),
            related_records: self.__unsafe_private_named.9.unwrap(),
            threat_signatures: self.__unsafe_private_named.10,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RepoView<'a> {
        RepoView {
            deactivated_at: self.__unsafe_private_named.0,
            did: self.__unsafe_private_named.1.unwrap(),
            email: self.__unsafe_private_named.2,
            handle: self.__unsafe_private_named.3.unwrap(),
            indexed_at: self.__unsafe_private_named.4.unwrap(),
            invite_note: self.__unsafe_private_named.5,
            invited_by: self.__unsafe_private_named.6,
            invites_disabled: self.__unsafe_private_named.7,
            moderation: self.__unsafe_private_named.8.unwrap(),
            related_records: self.__unsafe_private_named.9.unwrap(),
            threat_signatures: self.__unsafe_private_named.10,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RepoView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "repoView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RepoViewDetail<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub email: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub email_confirmed_at: std::option::Option<
        jacquard_common::types::string::Datetime,
    >,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invite_note: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invited_by: std::option::Option<crate::com_atproto::server::InviteCode<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invites: std::option::Option<Vec<crate::com_atproto::server::InviteCode<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub invites_disabled: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::ModerationDetail<'a>,
    #[serde(borrow)]
    pub related_records: Vec<jacquard_common::types::value::Data<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub threat_signatures: std::option::Option<
        Vec<crate::com_atproto::admin::ThreatSignature<'a>>,
    >,
}

pub mod repo_view_detail_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type IndexedAt;
        type RelatedRecords;
        type Moderation;
        type Did;
        type Handle;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type IndexedAt = Unset;
        type RelatedRecords = Unset;
        type Moderation = Unset;
        type Did = Unset;
        type Handle = Unset;
    }
    ///State transition - sets the `indexed_at` field to Set
    pub struct SetIndexedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetIndexedAt<S> {}
    impl<S: State> State for SetIndexedAt<S> {
        type IndexedAt = Set<members::indexed_at>;
        type RelatedRecords = S::RelatedRecords;
        type Moderation = S::Moderation;
        type Did = S::Did;
        type Handle = S::Handle;
    }
    ///State transition - sets the `related_records` field to Set
    pub struct SetRelatedRecords<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRelatedRecords<S> {}
    impl<S: State> State for SetRelatedRecords<S> {
        type IndexedAt = S::IndexedAt;
        type RelatedRecords = Set<members::related_records>;
        type Moderation = S::Moderation;
        type Did = S::Did;
        type Handle = S::Handle;
    }
    ///State transition - sets the `moderation` field to Set
    pub struct SetModeration<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetModeration<S> {}
    impl<S: State> State for SetModeration<S> {
        type IndexedAt = S::IndexedAt;
        type RelatedRecords = S::RelatedRecords;
        type Moderation = Set<members::moderation>;
        type Did = S::Did;
        type Handle = S::Handle;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type IndexedAt = S::IndexedAt;
        type RelatedRecords = S::RelatedRecords;
        type Moderation = S::Moderation;
        type Did = Set<members::did>;
        type Handle = S::Handle;
    }
    ///State transition - sets the `handle` field to Set
    pub struct SetHandle<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetHandle<S> {}
    impl<S: State> State for SetHandle<S> {
        type IndexedAt = S::IndexedAt;
        type RelatedRecords = S::RelatedRecords;
        type Moderation = S::Moderation;
        type Did = S::Did;
        type Handle = Set<members::handle>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `indexed_at` field
        pub struct indexed_at(());
        ///Marker type for the `related_records` field
        pub struct related_records(());
        ///Marker type for the `moderation` field
        pub struct moderation(());
        ///Marker type for the `did` field
        pub struct did(());
        ///Marker type for the `handle` field
        pub struct handle(());
    }
}

/// Builder for constructing an instance of this type
pub struct RepoViewDetailBuilder<'a, S: repo_view_detail_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Handle<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<crate::com_atproto::server::InviteCode<'a>>,
        ::core::option::Option<Vec<crate::com_atproto::server::InviteCode<'a>>>,
        ::core::option::Option<bool>,
        ::core::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
        ::core::option::Option<crate::tools_ozone::moderation::ModerationDetail<'a>>,
        ::core::option::Option<Vec<jacquard_common::types::value::Data<'a>>>,
        ::core::option::Option<Vec<crate::com_atproto::admin::ThreatSignature<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RepoViewDetail<'a> {
    /// Create a new builder for this type
    pub fn new() -> RepoViewDetailBuilder<'a, repo_view_detail_state::Empty> {
        RepoViewDetailBuilder::new()
    }
}

impl<'a> RepoViewDetailBuilder<'a, repo_view_detail_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RepoViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `deactivatedAt` field (optional)
    pub fn deactivated_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `deactivatedAt` field to an Option value (optional)
    pub fn maybe_deactivated_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> RepoViewDetailBuilder<'a, S>
where
    S: repo_view_detail_state::State,
    S::Did: repo_view_detail_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> RepoViewDetailBuilder<'a, repo_view_detail_state::SetDid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RepoViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `email` field (optional)
    pub fn email(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `email` field to an Option value (optional)
    pub fn maybe_email(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `emailConfirmedAt` field (optional)
    pub fn email_confirmed_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `emailConfirmedAt` field to an Option value (optional)
    pub fn maybe_email_confirmed_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S> RepoViewDetailBuilder<'a, S>
where
    S: repo_view_detail_state::State,
    S::Handle: repo_view_detail_state::IsUnset,
{
    /// Set the `handle` field (required)
    pub fn handle(
        mut self,
        value: impl Into<jacquard_common::types::string::Handle<'a>>,
    ) -> RepoViewDetailBuilder<'a, repo_view_detail_state::SetHandle<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        RepoViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RepoViewDetailBuilder<'a, S>
where
    S: repo_view_detail_state::State,
    S::IndexedAt: repo_view_detail_state::IsUnset,
{
    /// Set the `indexedAt` field (required)
    pub fn indexed_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> RepoViewDetailBuilder<'a, repo_view_detail_state::SetIndexedAt<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        RepoViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `inviteNote` field (optional)
    pub fn invite_note(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value.into();
        self
    }
    /// Set the `inviteNote` field to an Option value (optional)
    pub fn maybe_invite_note(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value;
        self
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `invitedBy` field (optional)
    pub fn invited_by(
        mut self,
        value: impl Into<Option<crate::com_atproto::server::InviteCode<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `invitedBy` field to an Option value (optional)
    pub fn maybe_invited_by(
        mut self,
        value: Option<crate::com_atproto::server::InviteCode<'a>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `invites` field (optional)
    pub fn invites(
        mut self,
        value: impl Into<Option<Vec<crate::com_atproto::server::InviteCode<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value.into();
        self
    }
    /// Set the `invites` field to an Option value (optional)
    pub fn maybe_invites(
        mut self,
        value: Option<Vec<crate::com_atproto::server::InviteCode<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value;
        self
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `invitesDisabled` field (optional)
    pub fn invites_disabled(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.9 = value.into();
        self
    }
    /// Set the `invitesDisabled` field to an Option value (optional)
    pub fn maybe_invites_disabled(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.9 = value;
        self
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `labels` field (optional)
    pub fn labels(
        mut self,
        value: impl Into<Option<Vec<crate::com_atproto::label::Label<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.10 = value.into();
        self
    }
    /// Set the `labels` field to an Option value (optional)
    pub fn maybe_labels(
        mut self,
        value: Option<Vec<crate::com_atproto::label::Label<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.10 = value;
        self
    }
}

impl<'a, S> RepoViewDetailBuilder<'a, S>
where
    S: repo_view_detail_state::State,
    S::Moderation: repo_view_detail_state::IsUnset,
{
    /// Set the `moderation` field (required)
    pub fn moderation(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::ModerationDetail<'a>>,
    ) -> RepoViewDetailBuilder<'a, repo_view_detail_state::SetModeration<S>> {
        self.__unsafe_private_named.11 = ::core::option::Option::Some(value.into());
        RepoViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RepoViewDetailBuilder<'a, S>
where
    S: repo_view_detail_state::State,
    S::RelatedRecords: repo_view_detail_state::IsUnset,
{
    /// Set the `relatedRecords` field (required)
    pub fn related_records(
        mut self,
        value: impl Into<Vec<jacquard_common::types::value::Data<'a>>>,
    ) -> RepoViewDetailBuilder<'a, repo_view_detail_state::SetRelatedRecords<S>> {
        self.__unsafe_private_named.12 = ::core::option::Option::Some(value.into());
        RepoViewDetailBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: repo_view_detail_state::State> RepoViewDetailBuilder<'a, S> {
    /// Set the `threatSignatures` field (optional)
    pub fn threat_signatures(
        mut self,
        value: impl Into<Option<Vec<crate::com_atproto::admin::ThreatSignature<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.13 = value.into();
        self
    }
    /// Set the `threatSignatures` field to an Option value (optional)
    pub fn maybe_threat_signatures(
        mut self,
        value: Option<Vec<crate::com_atproto::admin::ThreatSignature<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.13 = value;
        self
    }
}

impl<'a, S> RepoViewDetailBuilder<'a, S>
where
    S: repo_view_detail_state::State,
    S::IndexedAt: repo_view_detail_state::IsSet,
    S::RelatedRecords: repo_view_detail_state::IsSet,
    S::Moderation: repo_view_detail_state::IsSet,
    S::Did: repo_view_detail_state::IsSet,
    S::Handle: repo_view_detail_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RepoViewDetail<'a> {
        RepoViewDetail {
            deactivated_at: self.__unsafe_private_named.0,
            did: self.__unsafe_private_named.1.unwrap(),
            email: self.__unsafe_private_named.2,
            email_confirmed_at: self.__unsafe_private_named.3,
            handle: self.__unsafe_private_named.4.unwrap(),
            indexed_at: self.__unsafe_private_named.5.unwrap(),
            invite_note: self.__unsafe_private_named.6,
            invited_by: self.__unsafe_private_named.7,
            invites: self.__unsafe_private_named.8,
            invites_disabled: self.__unsafe_private_named.9,
            labels: self.__unsafe_private_named.10,
            moderation: self.__unsafe_private_named.11.unwrap(),
            related_records: self.__unsafe_private_named.12.unwrap(),
            threat_signatures: self.__unsafe_private_named.13,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RepoViewDetail<'a> {
        RepoViewDetail {
            deactivated_at: self.__unsafe_private_named.0,
            did: self.__unsafe_private_named.1.unwrap(),
            email: self.__unsafe_private_named.2,
            email_confirmed_at: self.__unsafe_private_named.3,
            handle: self.__unsafe_private_named.4.unwrap(),
            indexed_at: self.__unsafe_private_named.5.unwrap(),
            invite_note: self.__unsafe_private_named.6,
            invited_by: self.__unsafe_private_named.7,
            invites: self.__unsafe_private_named.8,
            invites_disabled: self.__unsafe_private_named.9,
            labels: self.__unsafe_private_named.10,
            moderation: self.__unsafe_private_named.11.unwrap(),
            related_records: self.__unsafe_private_named.12.unwrap(),
            threat_signatures: self.__unsafe_private_named.13,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RepoViewDetail<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "repoViewDetail"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RepoViewNotFound<'a> {
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
}

pub mod repo_view_not_found_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Did;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Did = Unset;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type Did = Set<members::did>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `did` field
        pub struct did(());
    }
}

/// Builder for constructing an instance of this type
pub struct RepoViewNotFoundBuilder<'a, S: repo_view_not_found_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RepoViewNotFound<'a> {
    /// Create a new builder for this type
    pub fn new() -> RepoViewNotFoundBuilder<'a, repo_view_not_found_state::Empty> {
        RepoViewNotFoundBuilder::new()
    }
}

impl<'a> RepoViewNotFoundBuilder<'a, repo_view_not_found_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RepoViewNotFoundBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None,),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RepoViewNotFoundBuilder<'a, S>
where
    S: repo_view_not_found_state::State,
    S::Did: repo_view_not_found_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> RepoViewNotFoundBuilder<'a, repo_view_not_found_state::SetDid<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        RepoViewNotFoundBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RepoViewNotFoundBuilder<'a, S>
where
    S: repo_view_not_found_state::State,
    S::Did: repo_view_not_found_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RepoViewNotFound<'a> {
        RepoViewNotFound {
            did: self.__unsafe_private_named.0.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RepoViewNotFound<'a> {
        RepoViewNotFound {
            did: self.__unsafe_private_named.0.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RepoViewNotFound<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "repoViewNotFound"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ReporterStats<'a> {
    /// The total number of reports made by the user on accounts.
    pub account_report_count: i64,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    /// The total number of accounts labeled as a result of the user's reports.
    pub labeled_account_count: i64,
    /// The total number of records labeled as a result of the user's reports.
    pub labeled_record_count: i64,
    /// The total number of reports made by the user on records.
    pub record_report_count: i64,
    /// The total number of accounts reported by the user.
    pub reported_account_count: i64,
    /// The total number of records reported by the user.
    pub reported_record_count: i64,
    /// The total number of accounts taken down as a result of the user's reports.
    pub takendown_account_count: i64,
    /// The total number of records taken down as a result of the user's reports.
    pub takendown_record_count: i64,
}

pub mod reporter_stats_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Did;
        type LabeledRecordCount;
        type ReportedAccountCount;
        type RecordReportCount;
        type ReportedRecordCount;
        type LabeledAccountCount;
        type AccountReportCount;
        type TakendownRecordCount;
        type TakendownAccountCount;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Did = Unset;
        type LabeledRecordCount = Unset;
        type ReportedAccountCount = Unset;
        type RecordReportCount = Unset;
        type ReportedRecordCount = Unset;
        type LabeledAccountCount = Unset;
        type AccountReportCount = Unset;
        type TakendownRecordCount = Unset;
        type TakendownAccountCount = Unset;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type Did = Set<members::did>;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `labeled_record_count` field to Set
    pub struct SetLabeledRecordCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetLabeledRecordCount<S> {}
    impl<S: State> State for SetLabeledRecordCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = Set<members::labeled_record_count>;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `reported_account_count` field to Set
    pub struct SetReportedAccountCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetReportedAccountCount<S> {}
    impl<S: State> State for SetReportedAccountCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = Set<members::reported_account_count>;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `record_report_count` field to Set
    pub struct SetRecordReportCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRecordReportCount<S> {}
    impl<S: State> State for SetRecordReportCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = Set<members::record_report_count>;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `reported_record_count` field to Set
    pub struct SetReportedRecordCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetReportedRecordCount<S> {}
    impl<S: State> State for SetReportedRecordCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = Set<members::reported_record_count>;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `labeled_account_count` field to Set
    pub struct SetLabeledAccountCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetLabeledAccountCount<S> {}
    impl<S: State> State for SetLabeledAccountCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = Set<members::labeled_account_count>;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `account_report_count` field to Set
    pub struct SetAccountReportCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccountReportCount<S> {}
    impl<S: State> State for SetAccountReportCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = Set<members::account_report_count>;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `takendown_record_count` field to Set
    pub struct SetTakendownRecordCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetTakendownRecordCount<S> {}
    impl<S: State> State for SetTakendownRecordCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = Set<members::takendown_record_count>;
        type TakendownAccountCount = S::TakendownAccountCount;
    }
    ///State transition - sets the `takendown_account_count` field to Set
    pub struct SetTakendownAccountCount<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetTakendownAccountCount<S> {}
    impl<S: State> State for SetTakendownAccountCount<S> {
        type Did = S::Did;
        type LabeledRecordCount = S::LabeledRecordCount;
        type ReportedAccountCount = S::ReportedAccountCount;
        type RecordReportCount = S::RecordReportCount;
        type ReportedRecordCount = S::ReportedRecordCount;
        type LabeledAccountCount = S::LabeledAccountCount;
        type AccountReportCount = S::AccountReportCount;
        type TakendownRecordCount = S::TakendownRecordCount;
        type TakendownAccountCount = Set<members::takendown_account_count>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `did` field
        pub struct did(());
        ///Marker type for the `labeled_record_count` field
        pub struct labeled_record_count(());
        ///Marker type for the `reported_account_count` field
        pub struct reported_account_count(());
        ///Marker type for the `record_report_count` field
        pub struct record_report_count(());
        ///Marker type for the `reported_record_count` field
        pub struct reported_record_count(());
        ///Marker type for the `labeled_account_count` field
        pub struct labeled_account_count(());
        ///Marker type for the `account_report_count` field
        pub struct account_report_count(());
        ///Marker type for the `takendown_record_count` field
        pub struct takendown_record_count(());
        ///Marker type for the `takendown_account_count` field
        pub struct takendown_account_count(());
    }
}

/// Builder for constructing an instance of this type
pub struct ReporterStatsBuilder<'a, S: reporter_stats_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<i64>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ReporterStats<'a> {
    /// Create a new builder for this type
    pub fn new() -> ReporterStatsBuilder<'a, reporter_stats_state::Empty> {
        ReporterStatsBuilder::new()
    }
}

impl<'a> ReporterStatsBuilder<'a, reporter_stats_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::AccountReportCount: reporter_stats_state::IsUnset,
{
    /// Set the `accountReportCount` field (required)
    pub fn account_report_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetAccountReportCount<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::Did: reporter_stats_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetDid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::LabeledAccountCount: reporter_stats_state::IsUnset,
{
    /// Set the `labeledAccountCount` field (required)
    pub fn labeled_account_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetLabeledAccountCount<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::LabeledRecordCount: reporter_stats_state::IsUnset,
{
    /// Set the `labeledRecordCount` field (required)
    pub fn labeled_record_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetLabeledRecordCount<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::RecordReportCount: reporter_stats_state::IsUnset,
{
    /// Set the `recordReportCount` field (required)
    pub fn record_report_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetRecordReportCount<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::ReportedAccountCount: reporter_stats_state::IsUnset,
{
    /// Set the `reportedAccountCount` field (required)
    pub fn reported_account_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetReportedAccountCount<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::ReportedRecordCount: reporter_stats_state::IsUnset,
{
    /// Set the `reportedRecordCount` field (required)
    pub fn reported_record_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetReportedRecordCount<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::TakendownAccountCount: reporter_stats_state::IsUnset,
{
    /// Set the `takendownAccountCount` field (required)
    pub fn takendown_account_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetTakendownAccountCount<S>> {
        self.__unsafe_private_named.7 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::TakendownRecordCount: reporter_stats_state::IsUnset,
{
    /// Set the `takendownRecordCount` field (required)
    pub fn takendown_record_count(
        mut self,
        value: impl Into<i64>,
    ) -> ReporterStatsBuilder<'a, reporter_stats_state::SetTakendownRecordCount<S>> {
        self.__unsafe_private_named.8 = ::core::option::Option::Some(value.into());
        ReporterStatsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ReporterStatsBuilder<'a, S>
where
    S: reporter_stats_state::State,
    S::Did: reporter_stats_state::IsSet,
    S::LabeledRecordCount: reporter_stats_state::IsSet,
    S::ReportedAccountCount: reporter_stats_state::IsSet,
    S::RecordReportCount: reporter_stats_state::IsSet,
    S::ReportedRecordCount: reporter_stats_state::IsSet,
    S::LabeledAccountCount: reporter_stats_state::IsSet,
    S::AccountReportCount: reporter_stats_state::IsSet,
    S::TakendownRecordCount: reporter_stats_state::IsSet,
    S::TakendownAccountCount: reporter_stats_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ReporterStats<'a> {
        ReporterStats {
            account_report_count: self.__unsafe_private_named.0.unwrap(),
            did: self.__unsafe_private_named.1.unwrap(),
            labeled_account_count: self.__unsafe_private_named.2.unwrap(),
            labeled_record_count: self.__unsafe_private_named.3.unwrap(),
            record_report_count: self.__unsafe_private_named.4.unwrap(),
            reported_account_count: self.__unsafe_private_named.5.unwrap(),
            reported_record_count: self.__unsafe_private_named.6.unwrap(),
            takendown_account_count: self.__unsafe_private_named.7.unwrap(),
            takendown_record_count: self.__unsafe_private_named.8.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ReporterStats<'a> {
        ReporterStats {
            account_report_count: self.__unsafe_private_named.0.unwrap(),
            did: self.__unsafe_private_named.1.unwrap(),
            labeled_account_count: self.__unsafe_private_named.2.unwrap(),
            labeled_record_count: self.__unsafe_private_named.3.unwrap(),
            record_report_count: self.__unsafe_private_named.4.unwrap(),
            reported_account_count: self.__unsafe_private_named.5.unwrap(),
            reported_record_count: self.__unsafe_private_named.6.unwrap(),
            takendown_account_count: self.__unsafe_private_named.7.unwrap(),
            takendown_record_count: self.__unsafe_private_named.8.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ReporterStats<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "reporterStats"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct ReviewClosed;
impl std::fmt::Display for ReviewClosed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "reviewClosed")
    }
}

/// Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct ReviewEscalated;
impl std::fmt::Display for ReviewEscalated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "reviewEscalated")
    }
}

/// Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct ReviewNone;
impl std::fmt::Display for ReviewNone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "reviewNone")
    }
}

/// Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct ReviewOpen;
impl std::fmt::Display for ReviewOpen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "reviewOpen")
    }
}

/// Account credentials revocation by moderators. Only works on DID subjects.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct RevokeAccountCredentialsEvent<'a> {
    /// Comment describing the reason for the revocation.
    #[serde(borrow)]
    pub comment: jacquard_common::CowStr<'a>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for RevokeAccountCredentialsEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "revokeAccountCredentialsEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Logs a scheduled takedown action for an account.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct ScheduleTakedownEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_after: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_until: std::option::Option<jacquard_common::types::string::Datetime>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ScheduleTakedownEvent<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "scheduleTakedownEvent"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// View of a scheduled moderation action
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ScheduledActionView<'a> {
    /// Type of action to be executed
    #[serde(borrow)]
    pub action: ScheduledActionViewAction<'a>,
    /// When the scheduled action was created
    pub created_at: jacquard_common::types::string::Datetime,
    /// DID of the user who created this scheduled action
    #[serde(borrow)]
    pub created_by: jacquard_common::types::string::Did<'a>,
    /// Subject DID for the action
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    /// Serialized event object that will be propagated to the event when performed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub event_data: std::option::Option<jacquard_common::types::value::Data<'a>>,
    /// Earliest time to execute the action (for randomized scheduling)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_after: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Exact time to execute the action
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Latest time to execute the action (for randomized scheduling)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_until: std::option::Option<jacquard_common::types::string::Datetime>,
    /// ID of the moderation event created when action was successfully executed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_event_id: std::option::Option<i64>,
    /// Auto-incrementing row ID
    pub id: i64,
    /// When the action was last attempted to be executed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_executed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Reason for the last execution failure
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub last_failure_reason: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Whether execution time should be randomized within the specified range
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub randomize_execution: std::option::Option<bool>,
    /// Current status of the scheduled action
    #[serde(borrow)]
    pub status: ScheduledActionViewStatus<'a>,
    /// When the scheduled action was last updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub updated_at: std::option::Option<jacquard_common::types::string::Datetime>,
}

pub mod scheduled_action_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type CreatedBy;
        type CreatedAt;
        type Status;
        type Id;
        type Did;
        type Action;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type CreatedBy = Unset;
        type CreatedAt = Unset;
        type Status = Unset;
        type Id = Unset;
        type Did = Unset;
        type Action = Unset;
    }
    ///State transition - sets the `created_by` field to Set
    pub struct SetCreatedBy<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedBy<S> {}
    impl<S: State> State for SetCreatedBy<S> {
        type CreatedBy = Set<members::created_by>;
        type CreatedAt = S::CreatedAt;
        type Status = S::Status;
        type Id = S::Id;
        type Did = S::Did;
        type Action = S::Action;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = Set<members::created_at>;
        type Status = S::Status;
        type Id = S::Id;
        type Did = S::Did;
        type Action = S::Action;
    }
    ///State transition - sets the `status` field to Set
    pub struct SetStatus<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetStatus<S> {}
    impl<S: State> State for SetStatus<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Status = Set<members::status>;
        type Id = S::Id;
        type Did = S::Did;
        type Action = S::Action;
    }
    ///State transition - sets the `id` field to Set
    pub struct SetId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetId<S> {}
    impl<S: State> State for SetId<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Status = S::Status;
        type Id = Set<members::id>;
        type Did = S::Did;
        type Action = S::Action;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Status = S::Status;
        type Id = S::Id;
        type Did = Set<members::did>;
        type Action = S::Action;
    }
    ///State transition - sets the `action` field to Set
    pub struct SetAction<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAction<S> {}
    impl<S: State> State for SetAction<S> {
        type CreatedBy = S::CreatedBy;
        type CreatedAt = S::CreatedAt;
        type Status = S::Status;
        type Id = S::Id;
        type Did = S::Did;
        type Action = Set<members::action>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `created_by` field
        pub struct created_by(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `status` field
        pub struct status(());
        ///Marker type for the `id` field
        pub struct id(());
        ///Marker type for the `did` field
        pub struct did(());
        ///Marker type for the `action` field
        pub struct action(());
    }
}

/// Builder for constructing an instance of this type
pub struct ScheduledActionViewBuilder<'a, S: scheduled_action_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<ScheduledActionViewAction<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::types::value::Data<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bool>,
        ::core::option::Option<ScheduledActionViewStatus<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ScheduledActionView<'a> {
    /// Create a new builder for this type
    pub fn new() -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::Empty> {
        ScheduledActionViewBuilder::new()
    }
}

impl<'a> ScheduledActionViewBuilder<'a, scheduled_action_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::Action: scheduled_action_view_state::IsUnset,
{
    /// Set the `action` field (required)
    pub fn action(
        mut self,
        value: impl Into<ScheduledActionViewAction<'a>>,
    ) -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::SetAction<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::CreatedAt: scheduled_action_view_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::CreatedBy: scheduled_action_view_state::IsUnset,
{
    /// Set the `createdBy` field (required)
    pub fn created_by(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::SetCreatedBy<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::Did: scheduled_action_view_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::SetDid<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `eventData` field (optional)
    pub fn event_data(
        mut self,
        value: impl Into<Option<jacquard_common::types::value::Data<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `eventData` field to an Option value (optional)
    pub fn maybe_event_data(
        mut self,
        value: Option<jacquard_common::types::value::Data<'a>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `executeAfter` field (optional)
    pub fn execute_after(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `executeAfter` field to an Option value (optional)
    pub fn maybe_execute_after(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `executeAt` field (optional)
    pub fn execute_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value.into();
        self
    }
    /// Set the `executeAt` field to an Option value (optional)
    pub fn maybe_execute_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.6 = value;
        self
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `executeUntil` field (optional)
    pub fn execute_until(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `executeUntil` field to an Option value (optional)
    pub fn maybe_execute_until(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `executionEventId` field (optional)
    pub fn execution_event_id(mut self, value: impl Into<Option<i64>>) -> Self {
        self.__unsafe_private_named.8 = value.into();
        self
    }
    /// Set the `executionEventId` field to an Option value (optional)
    pub fn maybe_execution_event_id(mut self, value: Option<i64>) -> Self {
        self.__unsafe_private_named.8 = value;
        self
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::Id: scheduled_action_view_state::IsUnset,
{
    /// Set the `id` field (required)
    pub fn id(
        mut self,
        value: impl Into<i64>,
    ) -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::SetId<S>> {
        self.__unsafe_private_named.9 = ::core::option::Option::Some(value.into());
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `lastExecutedAt` field (optional)
    pub fn last_executed_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.10 = value.into();
        self
    }
    /// Set the `lastExecutedAt` field to an Option value (optional)
    pub fn maybe_last_executed_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.10 = value;
        self
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `lastFailureReason` field (optional)
    pub fn last_failure_reason(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.11 = value.into();
        self
    }
    /// Set the `lastFailureReason` field to an Option value (optional)
    pub fn maybe_last_failure_reason(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.11 = value;
        self
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `randomizeExecution` field (optional)
    pub fn randomize_execution(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.12 = value.into();
        self
    }
    /// Set the `randomizeExecution` field to an Option value (optional)
    pub fn maybe_randomize_execution(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.12 = value;
        self
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::Status: scheduled_action_view_state::IsUnset,
{
    /// Set the `status` field (required)
    pub fn status(
        mut self,
        value: impl Into<ScheduledActionViewStatus<'a>>,
    ) -> ScheduledActionViewBuilder<'a, scheduled_action_view_state::SetStatus<S>> {
        self.__unsafe_private_named.13 = ::core::option::Option::Some(value.into());
        ScheduledActionViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: scheduled_action_view_state::State> ScheduledActionViewBuilder<'a, S> {
    /// Set the `updatedAt` field (optional)
    pub fn updated_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.14 = value.into();
        self
    }
    /// Set the `updatedAt` field to an Option value (optional)
    pub fn maybe_updated_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.14 = value;
        self
    }
}

impl<'a, S> ScheduledActionViewBuilder<'a, S>
where
    S: scheduled_action_view_state::State,
    S::CreatedBy: scheduled_action_view_state::IsSet,
    S::CreatedAt: scheduled_action_view_state::IsSet,
    S::Status: scheduled_action_view_state::IsSet,
    S::Id: scheduled_action_view_state::IsSet,
    S::Did: scheduled_action_view_state::IsSet,
    S::Action: scheduled_action_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ScheduledActionView<'a> {
        ScheduledActionView {
            action: self.__unsafe_private_named.0.unwrap(),
            created_at: self.__unsafe_private_named.1.unwrap(),
            created_by: self.__unsafe_private_named.2.unwrap(),
            did: self.__unsafe_private_named.3.unwrap(),
            event_data: self.__unsafe_private_named.4,
            execute_after: self.__unsafe_private_named.5,
            execute_at: self.__unsafe_private_named.6,
            execute_until: self.__unsafe_private_named.7,
            execution_event_id: self.__unsafe_private_named.8,
            id: self.__unsafe_private_named.9.unwrap(),
            last_executed_at: self.__unsafe_private_named.10,
            last_failure_reason: self.__unsafe_private_named.11,
            randomize_execution: self.__unsafe_private_named.12,
            status: self.__unsafe_private_named.13.unwrap(),
            updated_at: self.__unsafe_private_named.14,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ScheduledActionView<'a> {
        ScheduledActionView {
            action: self.__unsafe_private_named.0.unwrap(),
            created_at: self.__unsafe_private_named.1.unwrap(),
            created_by: self.__unsafe_private_named.2.unwrap(),
            did: self.__unsafe_private_named.3.unwrap(),
            event_data: self.__unsafe_private_named.4,
            execute_after: self.__unsafe_private_named.5,
            execute_at: self.__unsafe_private_named.6,
            execute_until: self.__unsafe_private_named.7,
            execution_event_id: self.__unsafe_private_named.8,
            id: self.__unsafe_private_named.9.unwrap(),
            last_executed_at: self.__unsafe_private_named.10,
            last_failure_reason: self.__unsafe_private_named.11,
            randomize_execution: self.__unsafe_private_named.12,
            status: self.__unsafe_private_named.13.unwrap(),
            updated_at: self.__unsafe_private_named.14,
            extra_data: Some(extra_data),
        }
    }
}

/// Type of action to be executed
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ScheduledActionViewAction<'a> {
    Takedown,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> ScheduledActionViewAction<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Takedown => "takedown",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for ScheduledActionViewAction<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "takedown" => Self::Takedown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for ScheduledActionViewAction<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "takedown" => Self::Takedown,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for ScheduledActionViewAction<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for ScheduledActionViewAction<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for ScheduledActionViewAction<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for ScheduledActionViewAction<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for ScheduledActionViewAction<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for ScheduledActionViewAction<'_> {
    type Output = ScheduledActionViewAction<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ScheduledActionViewAction::Takedown => ScheduledActionViewAction::Takedown,
            ScheduledActionViewAction::Other(v) => {
                ScheduledActionViewAction::Other(v.into_static())
            }
        }
    }
}

/// Current status of the scheduled action
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ScheduledActionViewStatus<'a> {
    Pending,
    Executed,
    Cancelled,
    Failed,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> ScheduledActionViewStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Pending => "pending",
            Self::Executed => "executed",
            Self::Cancelled => "cancelled",
            Self::Failed => "failed",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for ScheduledActionViewStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "pending" => Self::Pending,
            "executed" => Self::Executed,
            "cancelled" => Self::Cancelled,
            "failed" => Self::Failed,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for ScheduledActionViewStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "pending" => Self::Pending,
            "executed" => Self::Executed,
            "cancelled" => Self::Cancelled,
            "failed" => Self::Failed,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for ScheduledActionViewStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for ScheduledActionViewStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for ScheduledActionViewStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for ScheduledActionViewStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for ScheduledActionViewStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for ScheduledActionViewStatus<'_> {
    type Output = ScheduledActionViewStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ScheduledActionViewStatus::Pending => ScheduledActionViewStatus::Pending,
            ScheduledActionViewStatus::Executed => ScheduledActionViewStatus::Executed,
            ScheduledActionViewStatus::Cancelled => ScheduledActionViewStatus::Cancelled,
            ScheduledActionViewStatus::Failed => ScheduledActionViewStatus::Failed,
            ScheduledActionViewStatus::Other(v) => {
                ScheduledActionViewStatus::Other(v.into_static())
            }
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ScheduledActionView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "scheduledActionView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SubjectReviewState<'a> {
    ToolsOzoneModerationDefsReviewOpen,
    ToolsOzoneModerationDefsReviewEscalated,
    ToolsOzoneModerationDefsReviewClosed,
    ToolsOzoneModerationDefsReviewNone,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> SubjectReviewState<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::ToolsOzoneModerationDefsReviewOpen => {
                "tools.ozone.moderation.defs#reviewOpen"
            }
            Self::ToolsOzoneModerationDefsReviewEscalated => {
                "tools.ozone.moderation.defs#reviewEscalated"
            }
            Self::ToolsOzoneModerationDefsReviewClosed => {
                "tools.ozone.moderation.defs#reviewClosed"
            }
            Self::ToolsOzoneModerationDefsReviewNone => {
                "tools.ozone.moderation.defs#reviewNone"
            }
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for SubjectReviewState<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "tools.ozone.moderation.defs#reviewOpen" => {
                Self::ToolsOzoneModerationDefsReviewOpen
            }
            "tools.ozone.moderation.defs#reviewEscalated" => {
                Self::ToolsOzoneModerationDefsReviewEscalated
            }
            "tools.ozone.moderation.defs#reviewClosed" => {
                Self::ToolsOzoneModerationDefsReviewClosed
            }
            "tools.ozone.moderation.defs#reviewNone" => {
                Self::ToolsOzoneModerationDefsReviewNone
            }
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for SubjectReviewState<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "tools.ozone.moderation.defs#reviewOpen" => {
                Self::ToolsOzoneModerationDefsReviewOpen
            }
            "tools.ozone.moderation.defs#reviewEscalated" => {
                Self::ToolsOzoneModerationDefsReviewEscalated
            }
            "tools.ozone.moderation.defs#reviewClosed" => {
                Self::ToolsOzoneModerationDefsReviewClosed
            }
            "tools.ozone.moderation.defs#reviewNone" => {
                Self::ToolsOzoneModerationDefsReviewNone
            }
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for SubjectReviewState<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> core::fmt::Display for SubjectReviewState<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> serde::Serialize for SubjectReviewState<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for SubjectReviewState<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for SubjectReviewState<'_> {
    type Output = SubjectReviewState<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectReviewState::ToolsOzoneModerationDefsReviewOpen => {
                SubjectReviewState::ToolsOzoneModerationDefsReviewOpen
            }
            SubjectReviewState::ToolsOzoneModerationDefsReviewEscalated => {
                SubjectReviewState::ToolsOzoneModerationDefsReviewEscalated
            }
            SubjectReviewState::ToolsOzoneModerationDefsReviewClosed => {
                SubjectReviewState::ToolsOzoneModerationDefsReviewClosed
            }
            SubjectReviewState::ToolsOzoneModerationDefsReviewNone => {
                SubjectReviewState::ToolsOzoneModerationDefsReviewNone
            }
            SubjectReviewState::Other(v) => SubjectReviewState::Other(v.into_static()),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct SubjectStatusView<'a> {
    /// Statistics related to the account subject
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub account_stats: std::option::Option<
        crate::tools_ozone::moderation::AccountStats<'a>,
    >,
    /// Strike information for the account (account-level only)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub account_strike: std::option::Option<
        crate::tools_ozone::moderation::AccountStrike<'a>,
    >,
    /// Current age assurance state of the subject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub age_assurance_state: std::option::Option<SubjectStatusViewAgeAssuranceState<'a>>,
    /// Whether or not the last successful update to age assurance was made by the user or admin.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub age_assurance_updated_by: std::option::Option<
        SubjectStatusViewAgeAssuranceUpdatedBy<'a>,
    >,
    /// True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appealed: std::option::Option<bool>,
    /// Sticky comment on the subject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Timestamp referencing the first moderation status impacting event was emitted on the subject
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub hosting: std::option::Option<SubjectStatusViewHosting<'a>>,
    pub id: i64,
    /// Timestamp referencing when the author of the subject appealed a moderation action
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_appealed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_reported_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_reviewed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub last_reviewed_by: std::option::Option<jacquard_common::types::string::Did<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mute_reporting_until: std::option::Option<
        jacquard_common::types::string::Datetime,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mute_until: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Numeric value representing the level of priority. Higher score means higher priority.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub priority_score: std::option::Option<i64>,
    /// Statistics related to the record subjects authored by the subject's account
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub records_stats: std::option::Option<
        crate::tools_ozone::moderation::RecordsStats<'a>,
    >,
    #[serde(borrow)]
    pub review_state: crate::tools_ozone::moderation::SubjectReviewState<'a>,
    #[serde(borrow)]
    pub subject: SubjectStatusViewSubject<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_blob_cids: std::option::Option<
        Vec<jacquard_common::types::string::Cid<'a>>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_repo_handle: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub suspend_until: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub tags: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub takendown: std::option::Option<bool>,
    /// Timestamp referencing when the last update was made to the moderation status of the subject
    pub updated_at: jacquard_common::types::string::Datetime,
}

pub mod subject_status_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Id;
        type Subject;
        type UpdatedAt;
        type ReviewState;
        type CreatedAt;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Id = Unset;
        type Subject = Unset;
        type UpdatedAt = Unset;
        type ReviewState = Unset;
        type CreatedAt = Unset;
    }
    ///State transition - sets the `id` field to Set
    pub struct SetId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetId<S> {}
    impl<S: State> State for SetId<S> {
        type Id = Set<members::id>;
        type Subject = S::Subject;
        type UpdatedAt = S::UpdatedAt;
        type ReviewState = S::ReviewState;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `subject` field to Set
    pub struct SetSubject<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubject<S> {}
    impl<S: State> State for SetSubject<S> {
        type Id = S::Id;
        type Subject = Set<members::subject>;
        type UpdatedAt = S::UpdatedAt;
        type ReviewState = S::ReviewState;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `updated_at` field to Set
    pub struct SetUpdatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUpdatedAt<S> {}
    impl<S: State> State for SetUpdatedAt<S> {
        type Id = S::Id;
        type Subject = S::Subject;
        type UpdatedAt = Set<members::updated_at>;
        type ReviewState = S::ReviewState;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `review_state` field to Set
    pub struct SetReviewState<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetReviewState<S> {}
    impl<S: State> State for SetReviewState<S> {
        type Id = S::Id;
        type Subject = S::Subject;
        type UpdatedAt = S::UpdatedAt;
        type ReviewState = Set<members::review_state>;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type Id = S::Id;
        type Subject = S::Subject;
        type UpdatedAt = S::UpdatedAt;
        type ReviewState = S::ReviewState;
        type CreatedAt = Set<members::created_at>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `id` field
        pub struct id(());
        ///Marker type for the `subject` field
        pub struct subject(());
        ///Marker type for the `updated_at` field
        pub struct updated_at(());
        ///Marker type for the `review_state` field
        pub struct review_state(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
    }
}

/// Builder for constructing an instance of this type
pub struct SubjectStatusViewBuilder<'a, S: subject_status_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::tools_ozone::moderation::AccountStats<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::AccountStrike<'a>>,
        ::core::option::Option<SubjectStatusViewAgeAssuranceState<'a>>,
        ::core::option::Option<SubjectStatusViewAgeAssuranceUpdatedBy<'a>>,
        ::core::option::Option<bool>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<SubjectStatusViewHosting<'a>>,
        ::core::option::Option<i64>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<i64>,
        ::core::option::Option<crate::tools_ozone::moderation::RecordsStats<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::SubjectReviewState<'a>>,
        ::core::option::Option<SubjectStatusViewSubject<'a>>,
        ::core::option::Option<Vec<jacquard_common::types::string::Cid<'a>>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<Vec<jacquard_common::CowStr<'a>>>,
        ::core::option::Option<bool>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> SubjectStatusView<'a> {
    /// Create a new builder for this type
    pub fn new() -> SubjectStatusViewBuilder<'a, subject_status_view_state::Empty> {
        SubjectStatusViewBuilder::new()
    }
}

impl<'a> SubjectStatusViewBuilder<'a, subject_status_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        SubjectStatusViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `accountStats` field (optional)
    pub fn account_stats(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::AccountStats<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `accountStats` field to an Option value (optional)
    pub fn maybe_account_stats(
        mut self,
        value: Option<crate::tools_ozone::moderation::AccountStats<'a>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `accountStrike` field (optional)
    pub fn account_strike(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::AccountStrike<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `accountStrike` field to an Option value (optional)
    pub fn maybe_account_strike(
        mut self,
        value: Option<crate::tools_ozone::moderation::AccountStrike<'a>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `ageAssuranceState` field (optional)
    pub fn age_assurance_state(
        mut self,
        value: impl Into<Option<SubjectStatusViewAgeAssuranceState<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `ageAssuranceState` field to an Option value (optional)
    pub fn maybe_age_assurance_state(
        mut self,
        value: Option<SubjectStatusViewAgeAssuranceState<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `ageAssuranceUpdatedBy` field (optional)
    pub fn age_assurance_updated_by(
        mut self,
        value: impl Into<Option<SubjectStatusViewAgeAssuranceUpdatedBy<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `ageAssuranceUpdatedBy` field to an Option value (optional)
    pub fn maybe_age_assurance_updated_by(
        mut self,
        value: Option<SubjectStatusViewAgeAssuranceUpdatedBy<'a>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `appealed` field (optional)
    pub fn appealed(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `appealed` field to an Option value (optional)
    pub fn maybe_appealed(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `comment` field (optional)
    pub fn comment(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `comment` field to an Option value (optional)
    pub fn maybe_comment(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S> SubjectStatusViewBuilder<'a, S>
where
    S: subject_status_view_state::State,
    S::CreatedAt: subject_status_view_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> SubjectStatusViewBuilder<'a, subject_status_view_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        SubjectStatusViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `hosting` field (optional)
    pub fn hosting(
        mut self,
        value: impl Into<Option<SubjectStatusViewHosting<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `hosting` field to an Option value (optional)
    pub fn maybe_hosting(mut self, value: Option<SubjectStatusViewHosting<'a>>) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S> SubjectStatusViewBuilder<'a, S>
where
    S: subject_status_view_state::State,
    S::Id: subject_status_view_state::IsUnset,
{
    /// Set the `id` field (required)
    pub fn id(
        mut self,
        value: impl Into<i64>,
    ) -> SubjectStatusViewBuilder<'a, subject_status_view_state::SetId<S>> {
        self.__unsafe_private_named.8 = ::core::option::Option::Some(value.into());
        SubjectStatusViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `lastAppealedAt` field (optional)
    pub fn last_appealed_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.9 = value.into();
        self
    }
    /// Set the `lastAppealedAt` field to an Option value (optional)
    pub fn maybe_last_appealed_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.9 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `lastReportedAt` field (optional)
    pub fn last_reported_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.10 = value.into();
        self
    }
    /// Set the `lastReportedAt` field to an Option value (optional)
    pub fn maybe_last_reported_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.10 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `lastReviewedAt` field (optional)
    pub fn last_reviewed_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.11 = value.into();
        self
    }
    /// Set the `lastReviewedAt` field to an Option value (optional)
    pub fn maybe_last_reviewed_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.11 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `lastReviewedBy` field (optional)
    pub fn last_reviewed_by(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Did<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.12 = value.into();
        self
    }
    /// Set the `lastReviewedBy` field to an Option value (optional)
    pub fn maybe_last_reviewed_by(
        mut self,
        value: Option<jacquard_common::types::string::Did<'a>>,
    ) -> Self {
        self.__unsafe_private_named.12 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `muteReportingUntil` field (optional)
    pub fn mute_reporting_until(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.13 = value.into();
        self
    }
    /// Set the `muteReportingUntil` field to an Option value (optional)
    pub fn maybe_mute_reporting_until(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.13 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `muteUntil` field (optional)
    pub fn mute_until(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.14 = value.into();
        self
    }
    /// Set the `muteUntil` field to an Option value (optional)
    pub fn maybe_mute_until(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.14 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `priorityScore` field (optional)
    pub fn priority_score(mut self, value: impl Into<Option<i64>>) -> Self {
        self.__unsafe_private_named.15 = value.into();
        self
    }
    /// Set the `priorityScore` field to an Option value (optional)
    pub fn maybe_priority_score(mut self, value: Option<i64>) -> Self {
        self.__unsafe_private_named.15 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `recordsStats` field (optional)
    pub fn records_stats(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::RecordsStats<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.16 = value.into();
        self
    }
    /// Set the `recordsStats` field to an Option value (optional)
    pub fn maybe_records_stats(
        mut self,
        value: Option<crate::tools_ozone::moderation::RecordsStats<'a>>,
    ) -> Self {
        self.__unsafe_private_named.16 = value;
        self
    }
}

impl<'a, S> SubjectStatusViewBuilder<'a, S>
where
    S: subject_status_view_state::State,
    S::ReviewState: subject_status_view_state::IsUnset,
{
    /// Set the `reviewState` field (required)
    pub fn review_state(
        mut self,
        value: impl Into<crate::tools_ozone::moderation::SubjectReviewState<'a>>,
    ) -> SubjectStatusViewBuilder<'a, subject_status_view_state::SetReviewState<S>> {
        self.__unsafe_private_named.17 = ::core::option::Option::Some(value.into());
        SubjectStatusViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubjectStatusViewBuilder<'a, S>
where
    S: subject_status_view_state::State,
    S::Subject: subject_status_view_state::IsUnset,
{
    /// Set the `subject` field (required)
    pub fn subject(
        mut self,
        value: impl Into<SubjectStatusViewSubject<'a>>,
    ) -> SubjectStatusViewBuilder<'a, subject_status_view_state::SetSubject<S>> {
        self.__unsafe_private_named.18 = ::core::option::Option::Some(value.into());
        SubjectStatusViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `subjectBlobCids` field (optional)
    pub fn subject_blob_cids(
        mut self,
        value: impl Into<Option<Vec<jacquard_common::types::string::Cid<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.19 = value.into();
        self
    }
    /// Set the `subjectBlobCids` field to an Option value (optional)
    pub fn maybe_subject_blob_cids(
        mut self,
        value: Option<Vec<jacquard_common::types::string::Cid<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.19 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `subjectRepoHandle` field (optional)
    pub fn subject_repo_handle(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.20 = value.into();
        self
    }
    /// Set the `subjectRepoHandle` field to an Option value (optional)
    pub fn maybe_subject_repo_handle(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.20 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `suspendUntil` field (optional)
    pub fn suspend_until(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.21 = value.into();
        self
    }
    /// Set the `suspendUntil` field to an Option value (optional)
    pub fn maybe_suspend_until(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.21 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `tags` field (optional)
    pub fn tags(
        mut self,
        value: impl Into<Option<Vec<jacquard_common::CowStr<'a>>>>,
    ) -> Self {
        self.__unsafe_private_named.22 = value.into();
        self
    }
    /// Set the `tags` field to an Option value (optional)
    pub fn maybe_tags(
        mut self,
        value: Option<Vec<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.22 = value;
        self
    }
}

impl<'a, S: subject_status_view_state::State> SubjectStatusViewBuilder<'a, S> {
    /// Set the `takendown` field (optional)
    pub fn takendown(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.23 = value.into();
        self
    }
    /// Set the `takendown` field to an Option value (optional)
    pub fn maybe_takendown(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.23 = value;
        self
    }
}

impl<'a, S> SubjectStatusViewBuilder<'a, S>
where
    S: subject_status_view_state::State,
    S::UpdatedAt: subject_status_view_state::IsUnset,
{
    /// Set the `updatedAt` field (required)
    pub fn updated_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> SubjectStatusViewBuilder<'a, subject_status_view_state::SetUpdatedAt<S>> {
        self.__unsafe_private_named.24 = ::core::option::Option::Some(value.into());
        SubjectStatusViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubjectStatusViewBuilder<'a, S>
where
    S: subject_status_view_state::State,
    S::Id: subject_status_view_state::IsSet,
    S::Subject: subject_status_view_state::IsSet,
    S::UpdatedAt: subject_status_view_state::IsSet,
    S::ReviewState: subject_status_view_state::IsSet,
    S::CreatedAt: subject_status_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> SubjectStatusView<'a> {
        SubjectStatusView {
            account_stats: self.__unsafe_private_named.0,
            account_strike: self.__unsafe_private_named.1,
            age_assurance_state: self.__unsafe_private_named.2,
            age_assurance_updated_by: self.__unsafe_private_named.3,
            appealed: self.__unsafe_private_named.4,
            comment: self.__unsafe_private_named.5,
            created_at: self.__unsafe_private_named.6.unwrap(),
            hosting: self.__unsafe_private_named.7,
            id: self.__unsafe_private_named.8.unwrap(),
            last_appealed_at: self.__unsafe_private_named.9,
            last_reported_at: self.__unsafe_private_named.10,
            last_reviewed_at: self.__unsafe_private_named.11,
            last_reviewed_by: self.__unsafe_private_named.12,
            mute_reporting_until: self.__unsafe_private_named.13,
            mute_until: self.__unsafe_private_named.14,
            priority_score: self.__unsafe_private_named.15,
            records_stats: self.__unsafe_private_named.16,
            review_state: self.__unsafe_private_named.17.unwrap(),
            subject: self.__unsafe_private_named.18.unwrap(),
            subject_blob_cids: self.__unsafe_private_named.19,
            subject_repo_handle: self.__unsafe_private_named.20,
            suspend_until: self.__unsafe_private_named.21,
            tags: self.__unsafe_private_named.22,
            takendown: self.__unsafe_private_named.23,
            updated_at: self.__unsafe_private_named.24.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> SubjectStatusView<'a> {
        SubjectStatusView {
            account_stats: self.__unsafe_private_named.0,
            account_strike: self.__unsafe_private_named.1,
            age_assurance_state: self.__unsafe_private_named.2,
            age_assurance_updated_by: self.__unsafe_private_named.3,
            appealed: self.__unsafe_private_named.4,
            comment: self.__unsafe_private_named.5,
            created_at: self.__unsafe_private_named.6.unwrap(),
            hosting: self.__unsafe_private_named.7,
            id: self.__unsafe_private_named.8.unwrap(),
            last_appealed_at: self.__unsafe_private_named.9,
            last_reported_at: self.__unsafe_private_named.10,
            last_reviewed_at: self.__unsafe_private_named.11,
            last_reviewed_by: self.__unsafe_private_named.12,
            mute_reporting_until: self.__unsafe_private_named.13,
            mute_until: self.__unsafe_private_named.14,
            priority_score: self.__unsafe_private_named.15,
            records_stats: self.__unsafe_private_named.16,
            review_state: self.__unsafe_private_named.17.unwrap(),
            subject: self.__unsafe_private_named.18.unwrap(),
            subject_blob_cids: self.__unsafe_private_named.19,
            subject_repo_handle: self.__unsafe_private_named.20,
            suspend_until: self.__unsafe_private_named.21,
            tags: self.__unsafe_private_named.22,
            takendown: self.__unsafe_private_named.23,
            updated_at: self.__unsafe_private_named.24.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

/// Current age assurance state of the subject.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SubjectStatusViewAgeAssuranceState<'a> {
    Pending,
    Assured,
    Unknown,
    Reset,
    Blocked,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> SubjectStatusViewAgeAssuranceState<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Pending => "pending",
            Self::Assured => "assured",
            Self::Unknown => "unknown",
            Self::Reset => "reset",
            Self::Blocked => "blocked",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for SubjectStatusViewAgeAssuranceState<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            "unknown" => Self::Unknown,
            "reset" => Self::Reset,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for SubjectStatusViewAgeAssuranceState<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            "unknown" => Self::Unknown,
            "reset" => Self::Reset,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for SubjectStatusViewAgeAssuranceState<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for SubjectStatusViewAgeAssuranceState<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for SubjectStatusViewAgeAssuranceState<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for SubjectStatusViewAgeAssuranceState<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for SubjectStatusViewAgeAssuranceState<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for SubjectStatusViewAgeAssuranceState<'_> {
    type Output = SubjectStatusViewAgeAssuranceState<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectStatusViewAgeAssuranceState::Pending => {
                SubjectStatusViewAgeAssuranceState::Pending
            }
            SubjectStatusViewAgeAssuranceState::Assured => {
                SubjectStatusViewAgeAssuranceState::Assured
            }
            SubjectStatusViewAgeAssuranceState::Unknown => {
                SubjectStatusViewAgeAssuranceState::Unknown
            }
            SubjectStatusViewAgeAssuranceState::Reset => {
                SubjectStatusViewAgeAssuranceState::Reset
            }
            SubjectStatusViewAgeAssuranceState::Blocked => {
                SubjectStatusViewAgeAssuranceState::Blocked
            }
            SubjectStatusViewAgeAssuranceState::Other(v) => {
                SubjectStatusViewAgeAssuranceState::Other(v.into_static())
            }
        }
    }
}

/// Whether or not the last successful update to age assurance was made by the user or admin.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    Admin,
    User,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Admin => "admin",
            Self::User => "user",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "admin" => Self::Admin,
            "user" => Self::User,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "admin" => Self::Admin,
            "user" => Self::User,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for SubjectStatusViewAgeAssuranceUpdatedBy<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for SubjectStatusViewAgeAssuranceUpdatedBy<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for SubjectStatusViewAgeAssuranceUpdatedBy<'_> {
    type Output = SubjectStatusViewAgeAssuranceUpdatedBy<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectStatusViewAgeAssuranceUpdatedBy::Admin => {
                SubjectStatusViewAgeAssuranceUpdatedBy::Admin
            }
            SubjectStatusViewAgeAssuranceUpdatedBy::User => {
                SubjectStatusViewAgeAssuranceUpdatedBy::User
            }
            SubjectStatusViewAgeAssuranceUpdatedBy::Other(v) => {
                SubjectStatusViewAgeAssuranceUpdatedBy::Other(v.into_static())
            }
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubjectStatusViewHosting<'a> {
    #[serde(rename = "tools.ozone.moderation.defs#accountHosting")]
    AccountHosting(Box<crate::tools_ozone::moderation::AccountHosting<'a>>),
    #[serde(rename = "tools.ozone.moderation.defs#recordHosting")]
    RecordHosting(Box<crate::tools_ozone::moderation::RecordHosting<'a>>),
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubjectStatusViewSubject<'a> {
    #[serde(rename = "com.atproto.admin.defs#repoRef")]
    RepoRef(Box<crate::com_atproto::admin::RepoRef<'a>>),
    #[serde(rename = "com.atproto.repo.strongRef")]
    StrongRef(Box<crate::com_atproto::repo::strong_ref::StrongRef<'a>>),
    #[serde(rename = "chat.bsky.convo.defs#messageRef")]
    MessageRef(Box<crate::chat_bsky::convo::MessageRef<'a>>),
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for SubjectStatusView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "subjectStatusView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.priority_score {
            if *value > 100i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Maximum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "priority_score",
                    ),
                    max: 100i64,
                    actual: *value,
                });
            }
        }
        if let Some(ref value) = self.priority_score {
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "priority_score",
                    ),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}

/// Detailed view of a subject. For record subjects, the author's repo and profile will be returned.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct SubjectView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub profile: std::option::Option<jacquard_common::types::value::Data<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub record: std::option::Option<
        crate::tools_ozone::moderation::RecordViewDetail<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub repo: std::option::Option<crate::tools_ozone::moderation::RepoViewDetail<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<
        crate::tools_ozone::moderation::SubjectStatusView<'a>,
    >,
    #[serde(borrow)]
    pub subject: jacquard_common::CowStr<'a>,
    #[serde(borrow)]
    pub r#type: crate::com_atproto::moderation::SubjectType<'a>,
}

pub mod subject_view_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Subject;
        type Type;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Subject = Unset;
        type Type = Unset;
    }
    ///State transition - sets the `subject` field to Set
    pub struct SetSubject<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubject<S> {}
    impl<S: State> State for SetSubject<S> {
        type Subject = Set<members::subject>;
        type Type = S::Type;
    }
    ///State transition - sets the `type` field to Set
    pub struct SetType<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetType<S> {}
    impl<S: State> State for SetType<S> {
        type Subject = S::Subject;
        type Type = Set<members::r#type>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `subject` field
        pub struct subject(());
        ///Marker type for the `type` field
        pub struct r#type(());
    }
}

/// Builder for constructing an instance of this type
pub struct SubjectViewBuilder<'a, S: subject_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::value::Data<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::RecordViewDetail<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::RepoViewDetail<'a>>,
        ::core::option::Option<crate::tools_ozone::moderation::SubjectStatusView<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<crate::com_atproto::moderation::SubjectType<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> SubjectView<'a> {
    /// Create a new builder for this type
    pub fn new() -> SubjectViewBuilder<'a, subject_view_state::Empty> {
        SubjectViewBuilder::new()
    }
}

impl<'a> SubjectViewBuilder<'a, subject_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        SubjectViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: subject_view_state::State> SubjectViewBuilder<'a, S> {
    /// Set the `profile` field (optional)
    pub fn profile(
        mut self,
        value: impl Into<Option<jacquard_common::types::value::Data<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `profile` field to an Option value (optional)
    pub fn maybe_profile(
        mut self,
        value: Option<jacquard_common::types::value::Data<'a>>,
    ) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: subject_view_state::State> SubjectViewBuilder<'a, S> {
    /// Set the `record` field (optional)
    pub fn record(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::RecordViewDetail<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `record` field to an Option value (optional)
    pub fn maybe_record(
        mut self,
        value: Option<crate::tools_ozone::moderation::RecordViewDetail<'a>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: subject_view_state::State> SubjectViewBuilder<'a, S> {
    /// Set the `repo` field (optional)
    pub fn repo(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::RepoViewDetail<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `repo` field to an Option value (optional)
    pub fn maybe_repo(
        mut self,
        value: Option<crate::tools_ozone::moderation::RepoViewDetail<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S: subject_view_state::State> SubjectViewBuilder<'a, S> {
    /// Set the `status` field (optional)
    pub fn status(
        mut self,
        value: impl Into<Option<crate::tools_ozone::moderation::SubjectStatusView<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `status` field to an Option value (optional)
    pub fn maybe_status(
        mut self,
        value: Option<crate::tools_ozone::moderation::SubjectStatusView<'a>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S> SubjectViewBuilder<'a, S>
where
    S: subject_view_state::State,
    S::Subject: subject_view_state::IsUnset,
{
    /// Set the `subject` field (required)
    pub fn subject(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> SubjectViewBuilder<'a, subject_view_state::SetSubject<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        SubjectViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubjectViewBuilder<'a, S>
where
    S: subject_view_state::State,
    S::Type: subject_view_state::IsUnset,
{
    /// Set the `type` field (required)
    pub fn r#type(
        mut self,
        value: impl Into<crate::com_atproto::moderation::SubjectType<'a>>,
    ) -> SubjectViewBuilder<'a, subject_view_state::SetType<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        SubjectViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubjectViewBuilder<'a, S>
where
    S: subject_view_state::State,
    S::Subject: subject_view_state::IsSet,
    S::Type: subject_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> SubjectView<'a> {
        SubjectView {
            profile: self.__unsafe_private_named.0,
            record: self.__unsafe_private_named.1,
            repo: self.__unsafe_private_named.2,
            status: self.__unsafe_private_named.3,
            subject: self.__unsafe_private_named.4.unwrap(),
            r#type: self.__unsafe_private_named.5.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> SubjectView<'a> {
        SubjectView {
            profile: self.__unsafe_private_named.0,
            record: self.__unsafe_private_named.1,
            repo: self.__unsafe_private_named.2,
            status: self.__unsafe_private_named.3,
            subject: self.__unsafe_private_named.4.unwrap(),
            r#type: self.__unsafe_private_named.5.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for SubjectView<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "subjectView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Moderation event timeline event for a PLC create operation
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct TimelineEventPlcCreate;
impl std::fmt::Display for TimelineEventPlcCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "timelineEventPlcCreate")
    }
}

/// Moderation event timeline event for generic PLC operation
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct TimelineEventPlcOperation;
impl std::fmt::Display for TimelineEventPlcOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "timelineEventPlcOperation")
    }
}

/// Moderation event timeline event for a PLC tombstone operation
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct TimelineEventPlcTombstone;
impl std::fmt::Display for TimelineEventPlcTombstone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "timelineEventPlcTombstone")
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct VideoDetails<'a> {
    pub height: i64,
    pub length: i64,
    pub width: i64,
}

pub mod video_details_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Length;
        type Width;
        type Height;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Length = Unset;
        type Width = Unset;
        type Height = Unset;
    }
    ///State transition - sets the `length` field to Set
    pub struct SetLength<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetLength<S> {}
    impl<S: State> State for SetLength<S> {
        type Length = Set<members::length>;
        type Width = S::Width;
        type Height = S::Height;
    }
    ///State transition - sets the `width` field to Set
    pub struct SetWidth<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetWidth<S> {}
    impl<S: State> State for SetWidth<S> {
        type Length = S::Length;
        type Width = Set<members::width>;
        type Height = S::Height;
    }
    ///State transition - sets the `height` field to Set
    pub struct SetHeight<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetHeight<S> {}
    impl<S: State> State for SetHeight<S> {
        type Length = S::Length;
        type Width = S::Width;
        type Height = Set<members::height>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `length` field
        pub struct length(());
        ///Marker type for the `width` field
        pub struct width(());
        ///Marker type for the `height` field
        pub struct height(());
    }
}

/// Builder for constructing an instance of this type
pub struct VideoDetailsBuilder<'a, S: video_details_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> VideoDetails<'a> {
    /// Create a new builder for this type
    pub fn new() -> VideoDetailsBuilder<'a, video_details_state::Empty> {
        VideoDetailsBuilder::new()
    }
}

impl<'a> VideoDetailsBuilder<'a, video_details_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        VideoDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> VideoDetailsBuilder<'a, S>
where
    S: video_details_state::State,
    S::Height: video_details_state::IsUnset,
{
    /// Set the `height` field (required)
    pub fn height(
        mut self,
        value: impl Into<i64>,
    ) -> VideoDetailsBuilder<'a, video_details_state::SetHeight<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        VideoDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> VideoDetailsBuilder<'a, S>
where
    S: video_details_state::State,
    S::Length: video_details_state::IsUnset,
{
    /// Set the `length` field (required)
    pub fn length(
        mut self,
        value: impl Into<i64>,
    ) -> VideoDetailsBuilder<'a, video_details_state::SetLength<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        VideoDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> VideoDetailsBuilder<'a, S>
where
    S: video_details_state::State,
    S::Width: video_details_state::IsUnset,
{
    /// Set the `width` field (required)
    pub fn width(
        mut self,
        value: impl Into<i64>,
    ) -> VideoDetailsBuilder<'a, video_details_state::SetWidth<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        VideoDetailsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> VideoDetailsBuilder<'a, S>
where
    S: video_details_state::State,
    S::Length: video_details_state::IsSet,
    S::Width: video_details_state::IsSet,
    S::Height: video_details_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> VideoDetails<'a> {
        VideoDetails {
            height: self.__unsafe_private_named.0.unwrap(),
            length: self.__unsafe_private_named.1.unwrap(),
            width: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> VideoDetails<'a> {
        VideoDetails {
            height: self.__unsafe_private_named.0.unwrap(),
            length: self.__unsafe_private_named.1.unwrap(),
            width: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for VideoDetails<'a> {
    fn nsid() -> &'static str {
        "tools.ozone.moderation.defs"
    }
    fn def_name() -> &'static str {
        "videoDetails"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_tools_ozone_moderation_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}