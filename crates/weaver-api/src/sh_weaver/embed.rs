// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: sh.weaver.embed.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod external;
pub mod images;
pub mod record_with_media;
pub mod records;
pub mod video;

/// Proportional size of the embed relative to the viewport in larger windows. The dimensions are percentage out of 100. Could we use more granularity? Maybe, but come on.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct PercentSize<'a> {
    pub height: i64,
    pub width: i64,
}

pub mod percent_size_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Width;
        type Height;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Width = Unset;
        type Height = Unset;
    }
    ///State transition - sets the `width` field to Set
    pub struct SetWidth<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetWidth<S> {}
    impl<S: State> State for SetWidth<S> {
        type Width = Set<members::width>;
        type Height = S::Height;
    }
    ///State transition - sets the `height` field to Set
    pub struct SetHeight<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetHeight<S> {}
    impl<S: State> State for SetHeight<S> {
        type Width = S::Width;
        type Height = Set<members::height>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `width` field
        pub struct width(());
        ///Marker type for the `height` field
        pub struct height(());
    }
}

/// Builder for constructing an instance of this type
pub struct PercentSizeBuilder<'a, S: percent_size_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (::core::option::Option<i64>, ::core::option::Option<i64>),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> PercentSize<'a> {
    /// Create a new builder for this type
    pub fn new() -> PercentSizeBuilder<'a, percent_size_state::Empty> {
        PercentSizeBuilder::new()
    }
}

impl<'a> PercentSizeBuilder<'a, percent_size_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        PercentSizeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> PercentSizeBuilder<'a, S>
where
    S: percent_size_state::State,
    S::Height: percent_size_state::IsUnset,
{
    /// Set the `height` field (required)
    pub fn height(
        mut self,
        value: impl Into<i64>,
    ) -> PercentSizeBuilder<'a, percent_size_state::SetHeight<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        PercentSizeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> PercentSizeBuilder<'a, S>
where
    S: percent_size_state::State,
    S::Width: percent_size_state::IsUnset,
{
    /// Set the `width` field (required)
    pub fn width(
        mut self,
        value: impl Into<i64>,
    ) -> PercentSizeBuilder<'a, percent_size_state::SetWidth<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        PercentSizeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> PercentSizeBuilder<'a, S>
where
    S: percent_size_state::State,
    S::Width: percent_size_state::IsSet,
    S::Height: percent_size_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> PercentSize<'a> {
        PercentSize {
            height: self.__unsafe_private_named.0.unwrap(),
            width: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> PercentSize<'a> {
        PercentSize {
            height: self.__unsafe_private_named.0.unwrap(),
            width: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

fn lexicon_doc_sh_weaver_embed_defs() -> ::jacquard_lexicon::lexicon::LexiconDoc<
    'static,
> {
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("sh.weaver.embed.defs"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::alloc::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("percentSize"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Proportional size of the embed relative to the viewport in larger windows. The dimensions are percentage out of 100. Could we use more granularity? Maybe, but come on.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_common::smol_str::SmolStr::new_static("height")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("height"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("pixelSize"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Pixel-exact embed size. The dimensions are logical pixels, subject to scaling, so 200px at X2 scale is 400px.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_common::smol_str::SmolStr::new_static("height")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("height"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("width"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for PercentSize<'a> {
    fn nsid() -> &'static str {
        "sh.weaver.embed.defs"
    }
    fn def_name() -> &'static str {
        "percentSize"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_sh_weaver_embed_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Pixel-exact embed size. The dimensions are logical pixels, subject to scaling, so 200px at X2 scale is 400px.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct PixelSize<'a> {
    pub height: i64,
    pub width: i64,
}

pub mod pixel_size_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Width;
        type Height;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Width = Unset;
        type Height = Unset;
    }
    ///State transition - sets the `width` field to Set
    pub struct SetWidth<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetWidth<S> {}
    impl<S: State> State for SetWidth<S> {
        type Width = Set<members::width>;
        type Height = S::Height;
    }
    ///State transition - sets the `height` field to Set
    pub struct SetHeight<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetHeight<S> {}
    impl<S: State> State for SetHeight<S> {
        type Width = S::Width;
        type Height = Set<members::height>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `width` field
        pub struct width(());
        ///Marker type for the `height` field
        pub struct height(());
    }
}

/// Builder for constructing an instance of this type
pub struct PixelSizeBuilder<'a, S: pixel_size_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (::core::option::Option<i64>, ::core::option::Option<i64>),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> PixelSize<'a> {
    /// Create a new builder for this type
    pub fn new() -> PixelSizeBuilder<'a, pixel_size_state::Empty> {
        PixelSizeBuilder::new()
    }
}

impl<'a> PixelSizeBuilder<'a, pixel_size_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        PixelSizeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> PixelSizeBuilder<'a, S>
where
    S: pixel_size_state::State,
    S::Height: pixel_size_state::IsUnset,
{
    /// Set the `height` field (required)
    pub fn height(
        mut self,
        value: impl Into<i64>,
    ) -> PixelSizeBuilder<'a, pixel_size_state::SetHeight<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        PixelSizeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> PixelSizeBuilder<'a, S>
where
    S: pixel_size_state::State,
    S::Width: pixel_size_state::IsUnset,
{
    /// Set the `width` field (required)
    pub fn width(
        mut self,
        value: impl Into<i64>,
    ) -> PixelSizeBuilder<'a, pixel_size_state::SetWidth<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        PixelSizeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> PixelSizeBuilder<'a, S>
where
    S: pixel_size_state::State,
    S::Width: pixel_size_state::IsSet,
    S::Height: pixel_size_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> PixelSize<'a> {
        PixelSize {
            height: self.__unsafe_private_named.0.unwrap(),
            width: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> PixelSize<'a> {
        PixelSize {
            height: self.__unsafe_private_named.0.unwrap(),
            width: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for PixelSize<'a> {
    fn nsid() -> &'static str {
        "sh.weaver.embed.defs"
    }
    fn def_name() -> &'static str {
        "pixelSize"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_sh_weaver_embed_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}