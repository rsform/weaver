// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: app.bsky.ageassurance.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod begin;
pub mod get_config;
pub mod get_state;

/// The access level granted based on Age Assurance data we've processed.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Access<'a> {
    Unknown,
    None,
    Safe,
    Full,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> Access<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::None => "none",
            Self::Safe => "safe",
            Self::Full => "full",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for Access<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "unknown" => Self::Unknown,
            "none" => Self::None,
            "safe" => Self::Safe,
            "full" => Self::Full,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for Access<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "unknown" => Self::Unknown,
            "none" => Self::None,
            "safe" => Self::Safe,
            "full" => Self::Full,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for Access<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> core::fmt::Display for Access<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> serde::Serialize for Access<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for Access<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for Access<'_> {
    type Output = Access<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            Access::Unknown => Access::Unknown,
            Access::None => Access::None,
            Access::Safe => Access::Safe,
            Access::Full => Access::Full,
            Access::Other(v) => Access::Other(v.into_static()),
        }
    }
}

///
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Config<'a> {
    /// The per-region Age Assurance configuration.
    #[serde(borrow)]
    pub regions: Vec<crate::app_bsky::ageassurance::ConfigRegion<'a>>,
}

pub mod config_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Regions;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Regions = Unset;
    }
    ///State transition - sets the `regions` field to Set
    pub struct SetRegions<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRegions<S> {}
    impl<S: State> State for SetRegions<S> {
        type Regions = Set<members::regions>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `regions` field
        pub struct regions(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigBuilder<'a, S: config_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<Vec<crate::app_bsky::ageassurance::ConfigRegion<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Config<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigBuilder<'a, config_state::Empty> {
        ConfigBuilder::new()
    }
}

impl<'a> ConfigBuilder<'a, config_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None,),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigBuilder<'a, S>
where
    S: config_state::State,
    S::Regions: config_state::IsUnset,
{
    /// Set the `regions` field (required)
    pub fn regions(
        mut self,
        value: impl Into<Vec<crate::app_bsky::ageassurance::ConfigRegion<'a>>>,
    ) -> ConfigBuilder<'a, config_state::SetRegions<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigBuilder<'a, S>
where
    S: config_state::State,
    S::Regions: config_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Config<'a> {
        Config {
            regions: self.__unsafe_private_named.0.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Config<'a> {
        Config {
            regions: self.__unsafe_private_named.0.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

fn lexicon_doc_app_bsky_ageassurance_defs() -> ::jacquard_lexicon::lexicon::LexiconDoc<
    'static,
> {
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("app.bsky.ageassurance.defs"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::alloc::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("access"),
                ::jacquard_lexicon::lexicon::LexUserType::String(::jacquard_lexicon::lexicon::LexString {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "The access level granted based on Age Assurance data we've processed.",
                        ),
                    ),
                    format: None,
                    default: None,
                    min_length: None,
                    max_length: None,
                    min_graphemes: None,
                    max_graphemes: None,
                    r#enum: None,
                    r#const: None,
                    known_values: None,
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("config"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(::jacquard_common::CowStr::new_static("")),
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("regions")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("regions"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The per-region Age Assurance configuration.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static(
                                        "app.bsky.ageassurance.defs#configRegion",
                                    ),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("configRegion"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "The Age Assurance configuration for a specific region.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("countryCode"),
                            ::jacquard_common::smol_str::SmolStr::new_static("rules")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "countryCode",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ISO 3166-1 alpha-2 country code this configuration applies to.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "regionCode",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ISO 3166-2 region code this configuration applies to. If omitted, the configuration applies to the entire country.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("rules"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ordered list of Age Assurance rules that apply to this region. Rules should be applied in order, and the first matching rule determines the access level granted. The rules array should always include a default rule as the last item.",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                    description: None,
                                    refs: vec![
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleDefault"),
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleIfDeclaredOverAge"),
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleIfDeclaredUnderAge"),
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleIfAssuredOverAge"),
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleIfAssuredUnderAge"),
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleIfAccountNewerThan"),
                                        ::jacquard_common::CowStr::new_static("#configRegionRuleIfAccountOlderThan")
                                    ],
                                    closed: None,
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleDefault",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies by default.",
                        ),
                    ),
                    required: Some(
                        vec![::jacquard_common::smol_str::SmolStr::new_static("access")],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleIfAccountNewerThan",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies if the account is equal-to or newer than a certain date.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("date"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("date"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The date threshold as a datetime string.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleIfAccountOlderThan",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies if the account is older than a certain date.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("date"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("date"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The date threshold as a datetime string.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleIfAssuredOverAge",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies if the user has been assured to be equal-to or over a certain age.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleIfAssuredUnderAge",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies if the user has been assured to be under a certain age.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleIfDeclaredOverAge",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies if the user has declared themselves equal-to or over a certain age.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static(
                    "configRegionRuleIfDeclaredUnderAge",
                ),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Age Assurance rule that applies if the user has declared themselves under a certain age.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("age"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: None,
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("event"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Object used to store Age Assurance data in stash.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_common::smol_str::SmolStr::new_static("attemptId"),
                            ::jacquard_common::smol_str::SmolStr::new_static("countryCode")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The access level granted based on Age Assurance data we've processed.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "attemptId",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The unique identifier for this instance of the Age Assurance flow, in UUID format.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "completeIp",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The IP address used when completing the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "completeUa",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The user agent used when completing the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "countryCode",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ISO 3166-1 alpha-2 country code provided when beginning the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The date and time of this write operation.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("email"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The email used for Age Assurance.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("initIp"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The IP address used when initiating the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("initUa"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The user agent used when initiating the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "regionCode",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The ISO 3166-2 region code provided when beginning the Age Assurance flow.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The status of the Age Assurance process.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("state"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "The user's computed Age Assurance state.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_common::smol_str::SmolStr::new_static("access")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("access"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#access",
                                ),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastInitiatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The timestamp when this state was last updated.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("status"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "app.bsky.ageassurance.defs#status",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("stateMetadata"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Additional metadata needed to compute Age Assurance state client-side.",
                        ),
                    ),
                    required: Some(vec![]),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::alloc::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "accountCreatedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "The account creation timestamp.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("status"),
                ::jacquard_lexicon::lexicon::LexUserType::String(::jacquard_lexicon::lexicon::LexString {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "The status of the Age Assurance process.",
                        ),
                    ),
                    format: None,
                    default: None,
                    min_length: None,
                    max_length: None,
                    min_graphemes: None,
                    max_graphemes: None,
                    r#enum: None,
                    r#const: None,
                    known_values: None,
                }),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Config<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "config"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// The Age Assurance configuration for a specific region.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegion<'a> {
    /// The ISO 3166-1 alpha-2 country code this configuration applies to.
    #[serde(borrow)]
    pub country_code: jacquard_common::CowStr<'a>,
    /// The ISO 3166-2 region code this configuration applies to. If omitted, the configuration applies to the entire country.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub region_code: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The ordered list of Age Assurance rules that apply to this region. Rules should be applied in order, and the first matching rule determines the access level granted. The rules array should always include a default rule as the last item.
    #[serde(borrow)]
    pub rules: Vec<ConfigRegionRulesItem<'a>>,
}

pub mod config_region_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Rules;
        type CountryCode;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Rules = Unset;
        type CountryCode = Unset;
    }
    ///State transition - sets the `rules` field to Set
    pub struct SetRules<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRules<S> {}
    impl<S: State> State for SetRules<S> {
        type Rules = Set<members::rules>;
        type CountryCode = S::CountryCode;
    }
    ///State transition - sets the `country_code` field to Set
    pub struct SetCountryCode<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCountryCode<S> {}
    impl<S: State> State for SetCountryCode<S> {
        type Rules = S::Rules;
        type CountryCode = Set<members::country_code>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `rules` field
        pub struct rules(());
        ///Marker type for the `country_code` field
        pub struct country_code(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionBuilder<'a, S: config_region_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<Vec<ConfigRegionRulesItem<'a>>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegion<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionBuilder<'a, config_region_state::Empty> {
        ConfigRegionBuilder::new()
    }
}

impl<'a> ConfigRegionBuilder<'a, config_region_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionBuilder<'a, S>
where
    S: config_region_state::State,
    S::CountryCode: config_region_state::IsUnset,
{
    /// Set the `countryCode` field (required)
    pub fn country_code(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> ConfigRegionBuilder<'a, config_region_state::SetCountryCode<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: config_region_state::State> ConfigRegionBuilder<'a, S> {
    /// Set the `regionCode` field (optional)
    pub fn region_code(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `regionCode` field to an Option value (optional)
    pub fn maybe_region_code(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> ConfigRegionBuilder<'a, S>
where
    S: config_region_state::State,
    S::Rules: config_region_state::IsUnset,
{
    /// Set the `rules` field (required)
    pub fn rules(
        mut self,
        value: impl Into<Vec<ConfigRegionRulesItem<'a>>>,
    ) -> ConfigRegionBuilder<'a, config_region_state::SetRules<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ConfigRegionBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionBuilder<'a, S>
where
    S: config_region_state::State,
    S::Rules: config_region_state::IsSet,
    S::CountryCode: config_region_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegion<'a> {
        ConfigRegion {
            country_code: self.__unsafe_private_named.0.unwrap(),
            region_code: self.__unsafe_private_named.1,
            rules: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegion<'a> {
        ConfigRegion {
            country_code: self.__unsafe_private_named.0.unwrap(),
            region_code: self.__unsafe_private_named.1,
            rules: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ConfigRegionRulesItem<'a> {
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleDefault")]
    ConfigRegionRuleDefault(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleDefault<'a>>,
    ),
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleIfDeclaredOverAge")]
    ConfigRegionRuleIfDeclaredOverAge(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleIfDeclaredOverAge<'a>>,
    ),
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleIfDeclaredUnderAge")]
    ConfigRegionRuleIfDeclaredUnderAge(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleIfDeclaredUnderAge<'a>>,
    ),
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleIfAssuredOverAge")]
    ConfigRegionRuleIfAssuredOverAge(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleIfAssuredOverAge<'a>>,
    ),
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleIfAssuredUnderAge")]
    ConfigRegionRuleIfAssuredUnderAge(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleIfAssuredUnderAge<'a>>,
    ),
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleIfAccountNewerThan")]
    ConfigRegionRuleIfAccountNewerThan(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleIfAccountNewerThan<'a>>,
    ),
    #[serde(rename = "app.bsky.ageassurance.defs#configRegionRuleIfAccountOlderThan")]
    ConfigRegionRuleIfAccountOlderThan(
        Box<crate::app_bsky::ageassurance::ConfigRegionRuleIfAccountOlderThan<'a>>,
    ),
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ConfigRegion<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegion"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies by default.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleDefault<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
}

pub mod config_region_rule_default_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Access = Unset;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleDefaultBuilder<
    'a,
    S: config_region_rule_default_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleDefault<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleDefaultBuilder<
        'a,
        config_region_rule_default_state::Empty,
    > {
        ConfigRegionRuleDefaultBuilder::new()
    }
}

impl<'a> ConfigRegionRuleDefaultBuilder<'a, config_region_rule_default_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleDefaultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None,),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleDefaultBuilder<'a, S>
where
    S: config_region_rule_default_state::State,
    S::Access: config_region_rule_default_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleDefaultBuilder<
        'a,
        config_region_rule_default_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleDefaultBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleDefaultBuilder<'a, S>
where
    S: config_region_rule_default_state::State,
    S::Access: config_region_rule_default_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleDefault<'a> {
        ConfigRegionRuleDefault {
            access: self.__unsafe_private_named.0.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleDefault<'a> {
        ConfigRegionRuleDefault {
            access: self.__unsafe_private_named.0.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ConfigRegionRuleDefault<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleDefault"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies if the account is equal-to or newer than a certain date.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleIfAccountNewerThan<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The date threshold as a datetime string.
    pub date: jacquard_common::types::string::Datetime,
}

pub mod config_region_rule_if_account_newer_than_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Date;
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Date = Unset;
        type Access = Unset;
    }
    ///State transition - sets the `date` field to Set
    pub struct SetDate<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDate<S> {}
    impl<S: State> State for SetDate<S> {
        type Date = Set<members::date>;
        type Access = S::Access;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Date = S::Date;
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `date` field
        pub struct date(());
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleIfAccountNewerThanBuilder<
    'a,
    S: config_region_rule_if_account_newer_than_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleIfAccountNewerThan<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleIfAccountNewerThanBuilder<
        'a,
        config_region_rule_if_account_newer_than_state::Empty,
    > {
        ConfigRegionRuleIfAccountNewerThanBuilder::new()
    }
}

impl<
    'a,
> ConfigRegionRuleIfAccountNewerThanBuilder<
    'a,
    config_region_rule_if_account_newer_than_state::Empty,
> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleIfAccountNewerThanBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAccountNewerThanBuilder<'a, S>
where
    S: config_region_rule_if_account_newer_than_state::State,
    S::Access: config_region_rule_if_account_newer_than_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleIfAccountNewerThanBuilder<
        'a,
        config_region_rule_if_account_newer_than_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAccountNewerThanBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAccountNewerThanBuilder<'a, S>
where
    S: config_region_rule_if_account_newer_than_state::State,
    S::Date: config_region_rule_if_account_newer_than_state::IsUnset,
{
    /// Set the `date` field (required)
    pub fn date(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> ConfigRegionRuleIfAccountNewerThanBuilder<
        'a,
        config_region_rule_if_account_newer_than_state::SetDate<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAccountNewerThanBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAccountNewerThanBuilder<'a, S>
where
    S: config_region_rule_if_account_newer_than_state::State,
    S::Date: config_region_rule_if_account_newer_than_state::IsSet,
    S::Access: config_region_rule_if_account_newer_than_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleIfAccountNewerThan<'a> {
        ConfigRegionRuleIfAccountNewerThan {
            access: self.__unsafe_private_named.0.unwrap(),
            date: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleIfAccountNewerThan<'a> {
        ConfigRegionRuleIfAccountNewerThan {
            access: self.__unsafe_private_named.0.unwrap(),
            date: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for ConfigRegionRuleIfAccountNewerThan<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleIfAccountNewerThan"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies if the account is older than a certain date.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleIfAccountOlderThan<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The date threshold as a datetime string.
    pub date: jacquard_common::types::string::Datetime,
}

pub mod config_region_rule_if_account_older_than_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Date;
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Date = Unset;
        type Access = Unset;
    }
    ///State transition - sets the `date` field to Set
    pub struct SetDate<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDate<S> {}
    impl<S: State> State for SetDate<S> {
        type Date = Set<members::date>;
        type Access = S::Access;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Date = S::Date;
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `date` field
        pub struct date(());
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleIfAccountOlderThanBuilder<
    'a,
    S: config_region_rule_if_account_older_than_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleIfAccountOlderThan<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleIfAccountOlderThanBuilder<
        'a,
        config_region_rule_if_account_older_than_state::Empty,
    > {
        ConfigRegionRuleIfAccountOlderThanBuilder::new()
    }
}

impl<
    'a,
> ConfigRegionRuleIfAccountOlderThanBuilder<
    'a,
    config_region_rule_if_account_older_than_state::Empty,
> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleIfAccountOlderThanBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAccountOlderThanBuilder<'a, S>
where
    S: config_region_rule_if_account_older_than_state::State,
    S::Access: config_region_rule_if_account_older_than_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleIfAccountOlderThanBuilder<
        'a,
        config_region_rule_if_account_older_than_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAccountOlderThanBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAccountOlderThanBuilder<'a, S>
where
    S: config_region_rule_if_account_older_than_state::State,
    S::Date: config_region_rule_if_account_older_than_state::IsUnset,
{
    /// Set the `date` field (required)
    pub fn date(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> ConfigRegionRuleIfAccountOlderThanBuilder<
        'a,
        config_region_rule_if_account_older_than_state::SetDate<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAccountOlderThanBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAccountOlderThanBuilder<'a, S>
where
    S: config_region_rule_if_account_older_than_state::State,
    S::Date: config_region_rule_if_account_older_than_state::IsSet,
    S::Access: config_region_rule_if_account_older_than_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleIfAccountOlderThan<'a> {
        ConfigRegionRuleIfAccountOlderThan {
            access: self.__unsafe_private_named.0.unwrap(),
            date: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleIfAccountOlderThan<'a> {
        ConfigRegionRuleIfAccountOlderThan {
            access: self.__unsafe_private_named.0.unwrap(),
            date: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for ConfigRegionRuleIfAccountOlderThan<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleIfAccountOlderThan"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies if the user has been assured to be equal-to or over a certain age.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleIfAssuredOverAge<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The age threshold as a whole integer.
    pub age: i64,
}

pub mod config_region_rule_if_assured_over_age_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Access;
        type Age;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Access = Unset;
        type Age = Unset;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Access = Set<members::access>;
        type Age = S::Age;
    }
    ///State transition - sets the `age` field to Set
    pub struct SetAge<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAge<S> {}
    impl<S: State> State for SetAge<S> {
        type Access = S::Access;
        type Age = Set<members::age>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `access` field
        pub struct access(());
        ///Marker type for the `age` field
        pub struct age(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleIfAssuredOverAgeBuilder<
    'a,
    S: config_region_rule_if_assured_over_age_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleIfAssuredOverAge<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleIfAssuredOverAgeBuilder<
        'a,
        config_region_rule_if_assured_over_age_state::Empty,
    > {
        ConfigRegionRuleIfAssuredOverAgeBuilder::new()
    }
}

impl<
    'a,
> ConfigRegionRuleIfAssuredOverAgeBuilder<
    'a,
    config_region_rule_if_assured_over_age_state::Empty,
> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleIfAssuredOverAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAssuredOverAgeBuilder<'a, S>
where
    S: config_region_rule_if_assured_over_age_state::State,
    S::Access: config_region_rule_if_assured_over_age_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleIfAssuredOverAgeBuilder<
        'a,
        config_region_rule_if_assured_over_age_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAssuredOverAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAssuredOverAgeBuilder<'a, S>
where
    S: config_region_rule_if_assured_over_age_state::State,
    S::Age: config_region_rule_if_assured_over_age_state::IsUnset,
{
    /// Set the `age` field (required)
    pub fn age(
        mut self,
        value: impl Into<i64>,
    ) -> ConfigRegionRuleIfAssuredOverAgeBuilder<
        'a,
        config_region_rule_if_assured_over_age_state::SetAge<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAssuredOverAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAssuredOverAgeBuilder<'a, S>
where
    S: config_region_rule_if_assured_over_age_state::State,
    S::Access: config_region_rule_if_assured_over_age_state::IsSet,
    S::Age: config_region_rule_if_assured_over_age_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleIfAssuredOverAge<'a> {
        ConfigRegionRuleIfAssuredOverAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleIfAssuredOverAge<'a> {
        ConfigRegionRuleIfAssuredOverAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for ConfigRegionRuleIfAssuredOverAge<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleIfAssuredOverAge"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies if the user has been assured to be under a certain age.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleIfAssuredUnderAge<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The age threshold as a whole integer.
    pub age: i64,
}

pub mod config_region_rule_if_assured_under_age_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Age;
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Age = Unset;
        type Access = Unset;
    }
    ///State transition - sets the `age` field to Set
    pub struct SetAge<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAge<S> {}
    impl<S: State> State for SetAge<S> {
        type Age = Set<members::age>;
        type Access = S::Access;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Age = S::Age;
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `age` field
        pub struct age(());
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleIfAssuredUnderAgeBuilder<
    'a,
    S: config_region_rule_if_assured_under_age_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleIfAssuredUnderAge<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleIfAssuredUnderAgeBuilder<
        'a,
        config_region_rule_if_assured_under_age_state::Empty,
    > {
        ConfigRegionRuleIfAssuredUnderAgeBuilder::new()
    }
}

impl<
    'a,
> ConfigRegionRuleIfAssuredUnderAgeBuilder<
    'a,
    config_region_rule_if_assured_under_age_state::Empty,
> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleIfAssuredUnderAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAssuredUnderAgeBuilder<'a, S>
where
    S: config_region_rule_if_assured_under_age_state::State,
    S::Access: config_region_rule_if_assured_under_age_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleIfAssuredUnderAgeBuilder<
        'a,
        config_region_rule_if_assured_under_age_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAssuredUnderAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAssuredUnderAgeBuilder<'a, S>
where
    S: config_region_rule_if_assured_under_age_state::State,
    S::Age: config_region_rule_if_assured_under_age_state::IsUnset,
{
    /// Set the `age` field (required)
    pub fn age(
        mut self,
        value: impl Into<i64>,
    ) -> ConfigRegionRuleIfAssuredUnderAgeBuilder<
        'a,
        config_region_rule_if_assured_under_age_state::SetAge<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfAssuredUnderAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfAssuredUnderAgeBuilder<'a, S>
where
    S: config_region_rule_if_assured_under_age_state::State,
    S::Age: config_region_rule_if_assured_under_age_state::IsSet,
    S::Access: config_region_rule_if_assured_under_age_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleIfAssuredUnderAge<'a> {
        ConfigRegionRuleIfAssuredUnderAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleIfAssuredUnderAge<'a> {
        ConfigRegionRuleIfAssuredUnderAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for ConfigRegionRuleIfAssuredUnderAge<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleIfAssuredUnderAge"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies if the user has declared themselves equal-to or over a certain age.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleIfDeclaredOverAge<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The age threshold as a whole integer.
    pub age: i64,
}

pub mod config_region_rule_if_declared_over_age_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Age;
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Age = Unset;
        type Access = Unset;
    }
    ///State transition - sets the `age` field to Set
    pub struct SetAge<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAge<S> {}
    impl<S: State> State for SetAge<S> {
        type Age = Set<members::age>;
        type Access = S::Access;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Age = S::Age;
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `age` field
        pub struct age(());
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleIfDeclaredOverAgeBuilder<
    'a,
    S: config_region_rule_if_declared_over_age_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleIfDeclaredOverAge<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleIfDeclaredOverAgeBuilder<
        'a,
        config_region_rule_if_declared_over_age_state::Empty,
    > {
        ConfigRegionRuleIfDeclaredOverAgeBuilder::new()
    }
}

impl<
    'a,
> ConfigRegionRuleIfDeclaredOverAgeBuilder<
    'a,
    config_region_rule_if_declared_over_age_state::Empty,
> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleIfDeclaredOverAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfDeclaredOverAgeBuilder<'a, S>
where
    S: config_region_rule_if_declared_over_age_state::State,
    S::Access: config_region_rule_if_declared_over_age_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleIfDeclaredOverAgeBuilder<
        'a,
        config_region_rule_if_declared_over_age_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfDeclaredOverAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfDeclaredOverAgeBuilder<'a, S>
where
    S: config_region_rule_if_declared_over_age_state::State,
    S::Age: config_region_rule_if_declared_over_age_state::IsUnset,
{
    /// Set the `age` field (required)
    pub fn age(
        mut self,
        value: impl Into<i64>,
    ) -> ConfigRegionRuleIfDeclaredOverAgeBuilder<
        'a,
        config_region_rule_if_declared_over_age_state::SetAge<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfDeclaredOverAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfDeclaredOverAgeBuilder<'a, S>
where
    S: config_region_rule_if_declared_over_age_state::State,
    S::Age: config_region_rule_if_declared_over_age_state::IsSet,
    S::Access: config_region_rule_if_declared_over_age_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleIfDeclaredOverAge<'a> {
        ConfigRegionRuleIfDeclaredOverAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleIfDeclaredOverAge<'a> {
        ConfigRegionRuleIfDeclaredOverAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for ConfigRegionRuleIfDeclaredOverAge<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleIfDeclaredOverAge"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Age Assurance rule that applies if the user has declared themselves under a certain age.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ConfigRegionRuleIfDeclaredUnderAge<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The age threshold as a whole integer.
    pub age: i64,
}

pub mod config_region_rule_if_declared_under_age_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Age;
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Age = Unset;
        type Access = Unset;
    }
    ///State transition - sets the `age` field to Set
    pub struct SetAge<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAge<S> {}
    impl<S: State> State for SetAge<S> {
        type Age = Set<members::age>;
        type Access = S::Access;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Age = S::Age;
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `age` field
        pub struct age(());
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConfigRegionRuleIfDeclaredUnderAgeBuilder<
    'a,
    S: config_region_rule_if_declared_under_age_state::State,
> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConfigRegionRuleIfDeclaredUnderAge<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConfigRegionRuleIfDeclaredUnderAgeBuilder<
        'a,
        config_region_rule_if_declared_under_age_state::Empty,
    > {
        ConfigRegionRuleIfDeclaredUnderAgeBuilder::new()
    }
}

impl<
    'a,
> ConfigRegionRuleIfDeclaredUnderAgeBuilder<
    'a,
    config_region_rule_if_declared_under_age_state::Empty,
> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConfigRegionRuleIfDeclaredUnderAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfDeclaredUnderAgeBuilder<'a, S>
where
    S: config_region_rule_if_declared_under_age_state::State,
    S::Access: config_region_rule_if_declared_under_age_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> ConfigRegionRuleIfDeclaredUnderAgeBuilder<
        'a,
        config_region_rule_if_declared_under_age_state::SetAccess<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfDeclaredUnderAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfDeclaredUnderAgeBuilder<'a, S>
where
    S: config_region_rule_if_declared_under_age_state::State,
    S::Age: config_region_rule_if_declared_under_age_state::IsUnset,
{
    /// Set the `age` field (required)
    pub fn age(
        mut self,
        value: impl Into<i64>,
    ) -> ConfigRegionRuleIfDeclaredUnderAgeBuilder<
        'a,
        config_region_rule_if_declared_under_age_state::SetAge<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConfigRegionRuleIfDeclaredUnderAgeBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConfigRegionRuleIfDeclaredUnderAgeBuilder<'a, S>
where
    S: config_region_rule_if_declared_under_age_state::State,
    S::Age: config_region_rule_if_declared_under_age_state::IsSet,
    S::Access: config_region_rule_if_declared_under_age_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConfigRegionRuleIfDeclaredUnderAge<'a> {
        ConfigRegionRuleIfDeclaredUnderAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConfigRegionRuleIfDeclaredUnderAge<'a> {
        ConfigRegionRuleIfDeclaredUnderAge {
            access: self.__unsafe_private_named.0.unwrap(),
            age: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema
for ConfigRegionRuleIfDeclaredUnderAge<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "configRegionRuleIfDeclaredUnderAge"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Object used to store Age Assurance data in stash.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Event<'a> {
    /// The access level granted based on Age Assurance data we've processed.
    #[serde(borrow)]
    pub access: EventAccess<'a>,
    /// The unique identifier for this instance of the Age Assurance flow, in UUID format.
    #[serde(borrow)]
    pub attempt_id: jacquard_common::CowStr<'a>,
    /// The IP address used when completing the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub complete_ip: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The user agent used when completing the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub complete_ua: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The ISO 3166-1 alpha-2 country code provided when beginning the Age Assurance flow.
    #[serde(borrow)]
    pub country_code: jacquard_common::CowStr<'a>,
    /// The date and time of this write operation.
    pub created_at: jacquard_common::types::string::Datetime,
    /// The email used for Age Assurance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub email: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The IP address used when initiating the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub init_ip: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The user agent used when initiating the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub init_ua: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The ISO 3166-2 region code provided when beginning the Age Assurance flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub region_code: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The status of the Age Assurance process.
    #[serde(borrow)]
    pub status: EventStatus<'a>,
}

pub mod event_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type CreatedAt;
        type Access;
        type Status;
        type AttemptId;
        type CountryCode;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type CreatedAt = Unset;
        type Access = Unset;
        type Status = Unset;
        type AttemptId = Unset;
        type CountryCode = Unset;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type CreatedAt = Set<members::created_at>;
        type Access = S::Access;
        type Status = S::Status;
        type AttemptId = S::AttemptId;
        type CountryCode = S::CountryCode;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type CreatedAt = S::CreatedAt;
        type Access = Set<members::access>;
        type Status = S::Status;
        type AttemptId = S::AttemptId;
        type CountryCode = S::CountryCode;
    }
    ///State transition - sets the `status` field to Set
    pub struct SetStatus<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetStatus<S> {}
    impl<S: State> State for SetStatus<S> {
        type CreatedAt = S::CreatedAt;
        type Access = S::Access;
        type Status = Set<members::status>;
        type AttemptId = S::AttemptId;
        type CountryCode = S::CountryCode;
    }
    ///State transition - sets the `attempt_id` field to Set
    pub struct SetAttemptId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAttemptId<S> {}
    impl<S: State> State for SetAttemptId<S> {
        type CreatedAt = S::CreatedAt;
        type Access = S::Access;
        type Status = S::Status;
        type AttemptId = Set<members::attempt_id>;
        type CountryCode = S::CountryCode;
    }
    ///State transition - sets the `country_code` field to Set
    pub struct SetCountryCode<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCountryCode<S> {}
    impl<S: State> State for SetCountryCode<S> {
        type CreatedAt = S::CreatedAt;
        type Access = S::Access;
        type Status = S::Status;
        type AttemptId = S::AttemptId;
        type CountryCode = Set<members::country_code>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `access` field
        pub struct access(());
        ///Marker type for the `status` field
        pub struct status(());
        ///Marker type for the `attempt_id` field
        pub struct attempt_id(());
        ///Marker type for the `country_code` field
        pub struct country_code(());
    }
}

/// Builder for constructing an instance of this type
pub struct EventBuilder<'a, S: event_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<EventAccess<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<EventStatus<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Event<'a> {
    /// Create a new builder for this type
    pub fn new() -> EventBuilder<'a, event_state::Empty> {
        EventBuilder::new()
    }
}

impl<'a> EventBuilder<'a, event_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        EventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EventBuilder<'a, S>
where
    S: event_state::State,
    S::Access: event_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<EventAccess<'a>>,
    ) -> EventBuilder<'a, event_state::SetAccess<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        EventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EventBuilder<'a, S>
where
    S: event_state::State,
    S::AttemptId: event_state::IsUnset,
{
    /// Set the `attemptId` field (required)
    pub fn attempt_id(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> EventBuilder<'a, event_state::SetAttemptId<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        EventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: event_state::State> EventBuilder<'a, S> {
    /// Set the `completeIp` field (optional)
    pub fn complete_ip(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `completeIp` field to an Option value (optional)
    pub fn maybe_complete_ip(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S: event_state::State> EventBuilder<'a, S> {
    /// Set the `completeUa` field (optional)
    pub fn complete_ua(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `completeUa` field to an Option value (optional)
    pub fn maybe_complete_ua(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S> EventBuilder<'a, S>
where
    S: event_state::State,
    S::CountryCode: event_state::IsUnset,
{
    /// Set the `countryCode` field (required)
    pub fn country_code(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> EventBuilder<'a, event_state::SetCountryCode<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        EventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EventBuilder<'a, S>
where
    S: event_state::State,
    S::CreatedAt: event_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> EventBuilder<'a, event_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        EventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: event_state::State> EventBuilder<'a, S> {
    /// Set the `email` field (optional)
    pub fn email(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.6 = value.into();
        self
    }
    /// Set the `email` field to an Option value (optional)
    pub fn maybe_email(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.6 = value;
        self
    }
}

impl<'a, S: event_state::State> EventBuilder<'a, S> {
    /// Set the `initIp` field (optional)
    pub fn init_ip(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `initIp` field to an Option value (optional)
    pub fn maybe_init_ip(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S: event_state::State> EventBuilder<'a, S> {
    /// Set the `initUa` field (optional)
    pub fn init_ua(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value.into();
        self
    }
    /// Set the `initUa` field to an Option value (optional)
    pub fn maybe_init_ua(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.8 = value;
        self
    }
}

impl<'a, S: event_state::State> EventBuilder<'a, S> {
    /// Set the `regionCode` field (optional)
    pub fn region_code(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.9 = value.into();
        self
    }
    /// Set the `regionCode` field to an Option value (optional)
    pub fn maybe_region_code(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.9 = value;
        self
    }
}

impl<'a, S> EventBuilder<'a, S>
where
    S: event_state::State,
    S::Status: event_state::IsUnset,
{
    /// Set the `status` field (required)
    pub fn status(
        mut self,
        value: impl Into<EventStatus<'a>>,
    ) -> EventBuilder<'a, event_state::SetStatus<S>> {
        self.__unsafe_private_named.10 = ::core::option::Option::Some(value.into());
        EventBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EventBuilder<'a, S>
where
    S: event_state::State,
    S::CreatedAt: event_state::IsSet,
    S::Access: event_state::IsSet,
    S::Status: event_state::IsSet,
    S::AttemptId: event_state::IsSet,
    S::CountryCode: event_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Event<'a> {
        Event {
            access: self.__unsafe_private_named.0.unwrap(),
            attempt_id: self.__unsafe_private_named.1.unwrap(),
            complete_ip: self.__unsafe_private_named.2,
            complete_ua: self.__unsafe_private_named.3,
            country_code: self.__unsafe_private_named.4.unwrap(),
            created_at: self.__unsafe_private_named.5.unwrap(),
            email: self.__unsafe_private_named.6,
            init_ip: self.__unsafe_private_named.7,
            init_ua: self.__unsafe_private_named.8,
            region_code: self.__unsafe_private_named.9,
            status: self.__unsafe_private_named.10.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Event<'a> {
        Event {
            access: self.__unsafe_private_named.0.unwrap(),
            attempt_id: self.__unsafe_private_named.1.unwrap(),
            complete_ip: self.__unsafe_private_named.2,
            complete_ua: self.__unsafe_private_named.3,
            country_code: self.__unsafe_private_named.4.unwrap(),
            created_at: self.__unsafe_private_named.5.unwrap(),
            email: self.__unsafe_private_named.6,
            init_ip: self.__unsafe_private_named.7,
            init_ua: self.__unsafe_private_named.8,
            region_code: self.__unsafe_private_named.9,
            status: self.__unsafe_private_named.10.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

/// The access level granted based on Age Assurance data we've processed.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum EventAccess<'a> {
    Unknown,
    None,
    Safe,
    Full,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> EventAccess<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::None => "none",
            Self::Safe => "safe",
            Self::Full => "full",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for EventAccess<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "unknown" => Self::Unknown,
            "none" => Self::None,
            "safe" => Self::Safe,
            "full" => Self::Full,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for EventAccess<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "unknown" => Self::Unknown,
            "none" => Self::None,
            "safe" => Self::Safe,
            "full" => Self::Full,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for EventAccess<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for EventAccess<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for EventAccess<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for EventAccess<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for EventAccess<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for EventAccess<'_> {
    type Output = EventAccess<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            EventAccess::Unknown => EventAccess::Unknown,
            EventAccess::None => EventAccess::None,
            EventAccess::Safe => EventAccess::Safe,
            EventAccess::Full => EventAccess::Full,
            EventAccess::Other(v) => EventAccess::Other(v.into_static()),
        }
    }
}

/// The status of the Age Assurance process.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum EventStatus<'a> {
    Unknown,
    Pending,
    Assured,
    Blocked,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> EventStatus<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::Pending => "pending",
            Self::Assured => "assured",
            Self::Blocked => "blocked",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for EventStatus<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "unknown" => Self::Unknown,
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for EventStatus<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "unknown" => Self::Unknown,
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> core::fmt::Display for EventStatus<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> AsRef<str> for EventStatus<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for EventStatus<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for EventStatus<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl<'a> Default for EventStatus<'a> {
    fn default() -> Self {
        Self::Other(Default::default())
    }
}

impl jacquard_common::IntoStatic for EventStatus<'_> {
    type Output = EventStatus<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            EventStatus::Unknown => EventStatus::Unknown,
            EventStatus::Pending => EventStatus::Pending,
            EventStatus::Assured => EventStatus::Assured,
            EventStatus::Blocked => EventStatus::Blocked,
            EventStatus::Other(v) => EventStatus::Other(v.into_static()),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Event<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "event"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// The user's computed Age Assurance state.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct State<'a> {
    #[serde(borrow)]
    pub access: crate::app_bsky::ageassurance::Access<'a>,
    /// The timestamp when this state was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_initiated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub status: crate::app_bsky::ageassurance::Status<'a>,
}

pub mod state_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Status;
        type Access;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Status = Unset;
        type Access = Unset;
    }
    ///State transition - sets the `status` field to Set
    pub struct SetStatus<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetStatus<S> {}
    impl<S: State> State for SetStatus<S> {
        type Status = Set<members::status>;
        type Access = S::Access;
    }
    ///State transition - sets the `access` field to Set
    pub struct SetAccess<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetAccess<S> {}
    impl<S: State> State for SetAccess<S> {
        type Status = S::Status;
        type Access = Set<members::access>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `status` field
        pub struct status(());
        ///Marker type for the `access` field
        pub struct access(());
    }
}

/// Builder for constructing an instance of this type
pub struct StateBuilder<'a, S: state_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<crate::app_bsky::ageassurance::Access<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<crate::app_bsky::ageassurance::Status<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> State<'a> {
    /// Create a new builder for this type
    pub fn new() -> StateBuilder<'a, state_state::Empty> {
        StateBuilder::new()
    }
}

impl<'a> StateBuilder<'a, state_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        StateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> StateBuilder<'a, S>
where
    S: state_state::State,
    S::Access: state_state::IsUnset,
{
    /// Set the `access` field (required)
    pub fn access(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Access<'a>>,
    ) -> StateBuilder<'a, state_state::SetAccess<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        StateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: state_state::State> StateBuilder<'a, S> {
    /// Set the `lastInitiatedAt` field (optional)
    pub fn last_initiated_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `lastInitiatedAt` field to an Option value (optional)
    pub fn maybe_last_initiated_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> StateBuilder<'a, S>
where
    S: state_state::State,
    S::Status: state_state::IsUnset,
{
    /// Set the `status` field (required)
    pub fn status(
        mut self,
        value: impl Into<crate::app_bsky::ageassurance::Status<'a>>,
    ) -> StateBuilder<'a, state_state::SetStatus<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        StateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> StateBuilder<'a, S>
where
    S: state_state::State,
    S::Status: state_state::IsSet,
    S::Access: state_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> State<'a> {
        State {
            access: self.__unsafe_private_named.0.unwrap(),
            last_initiated_at: self.__unsafe_private_named.1,
            status: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> State<'a> {
        State {
            access: self.__unsafe_private_named.0.unwrap(),
            last_initiated_at: self.__unsafe_private_named.1,
            status: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for State<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "state"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Additional metadata needed to compute Age Assurance state client-side.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default
)]
#[serde(rename_all = "camelCase")]
pub struct StateMetadata<'a> {
    /// The account creation timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub account_created_at: std::option::Option<
        jacquard_common::types::string::Datetime,
    >,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for StateMetadata<'a> {
    fn nsid() -> &'static str {
        "app.bsky.ageassurance.defs"
    }
    fn def_name() -> &'static str {
        "stateMetadata"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_app_bsky_ageassurance_defs()
    }
    fn validate(
        &self,
    ) -> ::core::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// The status of the Age Assurance process.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Status<'a> {
    Unknown,
    Pending,
    Assured,
    Blocked,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> Status<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::Pending => "pending",
            Self::Assured => "assured",
            Self::Blocked => "blocked",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for Status<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "unknown" => Self::Unknown,
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for Status<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "unknown" => Self::Unknown,
            "pending" => Self::Pending,
            "assured" => Self::Assured,
            "blocked" => Self::Blocked,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for Status<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> core::fmt::Display for Status<'a> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> serde::Serialize for Status<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for Status<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for Status<'_> {
    type Output = Status<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            Status::Unknown => Status::Unknown,
            Status::Pending => Status::Pending,
            Status::Assured => Status::Assured,
            Status::Blocked => Status::Blocked,
            Status::Other(v) => Status::Other(v.into_static()),
        }
    }
}