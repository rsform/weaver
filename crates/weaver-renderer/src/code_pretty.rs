use markdown_weaver_escape::StrWrite;
// use syntect::highlighting::ThemeSet;
// use syntect::html::css_for_theme_with_class_style;
use syntect::html::{ClassStyle, ClassedHTMLGenerator};
use syntect::parsing::SyntaxSet;
use syntect::util::LinesWithEndings;

/// Perform syntax highlighting on a code block.
/// This requires an external stylesheet, also generated by syntect to be loaded by the page.
/// The syntect SyntaxSet is also provided, so that it is not re-created on every call.
pub fn highlight<M>(
    syn_set: &SyntaxSet,
    lang: Option<&str>,
    code: impl AsRef<str>,
    writer: &mut M,
) -> Result<(), Box<dyn std::error::Error + Send + Sync + 'static>>
where
    M: StrWrite,
    <M as StrWrite>::Error: std::error::Error + Send + Sync + 'static,
{
    let lang_syn = if let Some(lang) = lang {
        syn_set
            .find_syntax_by_token(lang)
            .unwrap_or_else(|| syn_set.find_syntax_plain_text())
    } else {
        syn_set
            .find_syntax_by_first_line(code.as_ref())
            .unwrap_or_else(|| syn_set.find_syntax_plain_text())
    };
    writer.write_str("<pre><code class=\"language-")?;
    writer.write_str(&lang_syn.name)?;
    writer.write_str("\">")?;

    let mut html_gen = ClassedHTMLGenerator::new_with_class_style(
        lang_syn,
        syn_set,
        ClassStyle::SpacedPrefixed { prefix: CSS_PREFIX },
    );
    for line in LinesWithEndings::from(code.as_ref()) {
        html_gen
            .parse_html_for_line_which_includes_newline(line)
            .unwrap();
    }
    writer.write_str(&html_gen.finalize())?;
    writer.write_str("</code></pre>")?;
    Ok(())
}

pub const CSS_PREFIX: &str = "wvrcode-";
